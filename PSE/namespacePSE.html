<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>PSE Project: PSE Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PSE Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">PSE Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPSE_1_1PSE.html">PSE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to contain various variables for <a class="el" href="classPSE_1_1PSE.html" title="Class to contain various variables for PSE solution. ">PSE</a> solution.  <a href="classPSE_1_1PSE.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a34e5a20f5f1deeb44a0bb7b5c2ed9953"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a34e5a20f5f1deeb44a0bb7b5c2ed9953">Ax_b</a> (const PetscScalar *const *Ain, Vec &amp;x, const PetscScalar bin[], const PetscInt &amp;n)</td></tr>
<tr class="memdesc:a34e5a20f5f1deeb44a0bb7b5c2ed9953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves \(x\) in \(Ax=b\) linalg problem using PETSc in parallel Useful for solving small systems of equations, such as finite difference coefficients for given stencils.  <a href="#a34e5a20f5f1deeb44a0bb7b5c2ed9953">More...</a><br/></td></tr>
<tr class="separator:a34e5a20f5f1deeb44a0bb7b5c2ed9953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95785703297cd3c22a8ad3035ccb0d6f"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a95785703297cd3c22a8ad3035ccb0d6f">Ax_b</a> (const Mat &amp;A, Vec &amp;x, const Vec &amp;b, const PetscInt &amp;n)</td></tr>
<tr class="memdesc:a95785703297cd3c22a8ad3035ccb0d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves \(x\) in \(Ax=b\) linalg problem using PETSc in parallel.  <a href="#a95785703297cd3c22a8ad3035ccb0d6f">More...</a><br/></td></tr>
<tr class="separator:a95785703297cd3c22a8ad3035ccb0d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7aefd0b610d54fee980cd1cd96daa41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#ae7aefd0b610d54fee980cd1cd96daa41">base_flow</a> (<a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data)</td></tr>
<tr class="memdesc:ae7aefd0b610d54fee980cd1cd96daa41"><td class="mdescLeft">&#160;</td><td class="mdescRight">set plane channel flow velocity variables \(U, U_x, U_y,\) and etc  use this once to set the vectors with the velocity of plane channel flow (max u=1)  <a href="#ae7aefd0b610d54fee980cd1cd96daa41">More...</a><br/></td></tr>
<tr class="separator:ae7aefd0b610d54fee980cd1cd96daa41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8518bbf640f7df9a882d0f9d4f92d27"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#ad8518bbf640f7df9a882d0f9d4f92d27">_bblf</a> (const PetscScalar input[3], PetscScalar output[3])</td></tr>
<tr class="memdesc:ad8518bbf640f7df9a882d0f9d4f92d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blasius boundary layer function to integrate. Similarity Blasius ODE broken into three coupled equations </p>
<p class="formulaDsp">
\[ \begin{aligned} f&#39;&#39; &amp;= \int -ff&#39;&#39; d\eta\\ f&#39; &amp;= \int f&#39;&#39; d\eta\\ f &amp;= \int f&#39; d\eta\\ \end{aligned} \]
</p>
<p>.  <a href="#ad8518bbf640f7df9a882d0f9d4f92d27">More...</a><br/></td></tr>
<tr class="separator:ad8518bbf640f7df9a882d0f9d4f92d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b3cf1ddae425e811cf278753d2440e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#ae6b3cf1ddae425e811cf278753d2440e">calc_Closure</a> (PetscScalar &amp;I, <a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data)</td></tr>
<tr class="memdesc:ae6b3cf1ddae425e811cf278753d2440e"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the closure equation \( \int_{\Omega} \hat{\textbf{q}}^\dagger \hat{\textbf{q}}_x dy \) and output the result  <a href="#ae6b3cf1ddae425e811cf278753d2440e">More...</a><br/></td></tr>
<tr class="separator:ae6b3cf1ddae425e811cf278753d2440e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6d3524c36acc4ba132b8051151ca97"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#afd6d3524c36acc4ba132b8051151ca97">factorial</a> (unsigned n)</td></tr>
<tr class="memdesc:afd6d3524c36acc4ba132b8051151ca97"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the factorial of an integer  <a href="#afd6d3524c36acc4ba132b8051151ca97">More...</a><br/></td></tr>
<tr class="separator:afd6d3524c36acc4ba132b8051151ca97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf121ec8492dfe6fd8cde8b6b05aaa14"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#aaf121ec8492dfe6fd8cde8b6b05aaa14">get_D_Coeffs</a> (const PetscScalar s[], const PetscInt &amp;n, Vec &amp;output, const PetscInt &amp;d=2)</td></tr>
<tr class="memdesc:aaf121ec8492dfe6fd8cde8b6b05aaa14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve arbitrary stencil points s of length N with order of derivatives d&lt;N can be obtained from equation on MIT website <a href="http://web.media.mit.edu/~crtaylor/calculator.html">http://web.media.mit.edu/~crtaylor/calculator.html</a> where the accuracy is determined as the usual form O(h^(N-d))  <a href="#aaf121ec8492dfe6fd8cde8b6b05aaa14">More...</a><br/></td></tr>
<tr class="separator:aaf121ec8492dfe6fd8cde8b6b05aaa14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a28bf5687be08e4dd183f9eff806487"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a6a28bf5687be08e4dd183f9eff806487">Init_Mat</a> (Mat &amp;A, const PetscInt &amp;n)</td></tr>
<tr class="memdesc:a6a28bf5687be08e4dd183f9eff806487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a Matrix A to be of size nxn.  <a href="#a6a28bf5687be08e4dd183f9eff806487">More...</a><br/></td></tr>
<tr class="separator:a6a28bf5687be08e4dd183f9eff806487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc379863dab0514427427caf2889d23d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#acc379863dab0514427427caf2889d23d">Init_Mat</a> (Mat &amp;A, const PetscInt &amp;m, const PetscInt &amp;n)</td></tr>
<tr class="memdesc:acc379863dab0514427427caf2889d23d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a Matrix A to be of size mxn.  <a href="#acc379863dab0514427427caf2889d23d">More...</a><br/></td></tr>
<tr class="separator:acc379863dab0514427427caf2889d23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929ef72234fddb31ff867fa1446a8905"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a929ef72234fddb31ff867fa1446a8905">Init_Vec</a> (Vec &amp;x, const PetscInt &amp;n)</td></tr>
<tr class="memdesc:a929ef72234fddb31ff867fa1446a8905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a vector x to be of size n.  <a href="#a929ef72234fddb31ff867fa1446a8905">More...</a><br/></td></tr>
<tr class="separator:a929ef72234fddb31ff867fa1446a8905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40bb9d0042e3aba3153311e517d8d3b"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#ad40bb9d0042e3aba3153311e517d8d3b">map_D</a> (Mat &amp;output, <a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data, const PetscInt &amp;n, Vec &amp;yVec, const PetscInt &amp;order=2, const PetscInt &amp;d=2, const PetscBool &amp;periodic=PETSC_FALSE, const PetscBool &amp;reduce_wall_order=PETSC_TRUE)</td></tr>
<tr class="memdesc:ad40bb9d0042e3aba3153311e517d8d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">map D matrix operator for specified order and derivative, for a non-uniform mesh  <a href="#ad40bb9d0042e3aba3153311e517d8d3b">More...</a><br/></td></tr>
<tr class="separator:ad40bb9d0042e3aba3153311e517d8d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac456c4c880624b7a6b907995a05e9b48"><td class="memItemLeft" align="right" valign="top">PetscErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#ac456c4c880624b7a6b907995a05e9b48">printScalar</a> (const PetscScalar x[], const PetscInt n=1, char const name[]=&quot;x&quot;, const PetscViewer viewer=PETSC_VIEWER_STDOUT_WORLD)</td></tr>
<tr class="memdesc:ac456c4c880624b7a6b907995a05e9b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print PetscScalar variable to screen.  <a href="#ac456c4c880624b7a6b907995a05e9b48">More...</a><br/></td></tr>
<tr class="separator:ac456c4c880624b7a6b907995a05e9b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728ecf3fee73eeb301802d577abd31dc"><td class="memItemLeft" align="right" valign="top">PetscErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a728ecf3fee73eeb301802d577abd31dc">printVec</a> (const Vec &amp;x, const PetscInt n, char const name[]=&quot;x&quot;)</td></tr>
<tr class="memdesc:a728ecf3fee73eeb301802d577abd31dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print Vec from PETSc type variable to screen.  <a href="#a728ecf3fee73eeb301802d577abd31dc">More...</a><br/></td></tr>
<tr class="separator:a728ecf3fee73eeb301802d577abd31dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da6b6642caa8372bbb1d60cac8d300d"><td class="memItemLeft" align="right" valign="top">PetscErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a3da6b6642caa8372bbb1d60cac8d300d">printInt</a> (const PetscInt x[], const PetscInt n=1, char const name[]=&quot;x&quot;)</td></tr>
<tr class="memdesc:a3da6b6642caa8372bbb1d60cac8d300d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print PetscInt variable to screen.  <a href="#a3da6b6642caa8372bbb1d60cac8d300d">More...</a><br/></td></tr>
<tr class="separator:a3da6b6642caa8372bbb1d60cac8d300d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd72375bfd6c3e459eec96fcc9fb25b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#adcd72375bfd6c3e459eec96fcc9fb25b">printVecView</a> (const Vec &amp;x, char const name[]=&quot;x viewer&quot;, const PetscViewerFormat format=PETSC_VIEWER_DEFAULT)</td></tr>
<tr class="memdesc:adcd72375bfd6c3e459eec96fcc9fb25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">view PetscVec variable to screen Open an X-window viewer. Note that we specify the same communicator for the viewer as we used for the distributed vector (PETSC_COMM_WORLD).  <a href="#adcd72375bfd6c3e459eec96fcc9fb25b">More...</a><br/></td></tr>
<tr class="separator:adcd72375bfd6c3e459eec96fcc9fb25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eca5e043cde66f140837461b4b533c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a4eca5e043cde66f140837461b4b533c5">printMatView</a> (const Mat &amp;A, char const name[]=&quot;A viewer&quot;, const PetscViewerFormat format=PETSC_VIEWER_DEFAULT)</td></tr>
<tr class="memdesc:a4eca5e043cde66f140837461b4b533c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">view Petsc Mat variable to screen Open an X-window viewer. Note that we specify the same communicator for the viewer as we used for the distributed vector (PETSC_COMM_WORLD).  <a href="#a4eca5e043cde66f140837461b4b533c5">More...</a><br/></td></tr>
<tr class="separator:a4eca5e043cde66f140837461b4b533c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805847775fb8d170ad2db3518044108b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a805847775fb8d170ad2db3518044108b">printMatASCII</a> (const Mat &amp;A, char const name[]=&quot;printMatASCII.txt&quot;, const PetscViewerFormat format=PETSC_VIEWER_DEFAULT)</td></tr>
<tr class="memdesc:a805847775fb8d170ad2db3518044108b"><td class="mdescLeft">&#160;</td><td class="mdescRight">view Petsc Mat variable to ASCII file  <a href="#a805847775fb8d170ad2db3518044108b">More...</a><br/></td></tr>
<tr class="separator:a805847775fb8d170ad2db3518044108b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7733a43624f64edc21e21f0d611e300a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a7733a43624f64edc21e21f0d611e300a">printMatGetDiagonalASCII</a> (const Mat &amp;A, char const name[]=&quot;printMatGetDiagonalASCII.txt&quot;, const PetscViewerFormat format=PETSC_VIEWER_DEFAULT)</td></tr>
<tr class="memdesc:a7733a43624f64edc21e21f0d611e300a"><td class="mdescLeft">&#160;</td><td class="mdescRight">print diagonal of Petsc Mat variable to ASCII file  <a href="#a7733a43624f64edc21e21f0d611e300a">More...</a><br/></td></tr>
<tr class="separator:a7733a43624f64edc21e21f0d611e300a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4364796301e74a3d38cbca8de4983dc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a4364796301e74a3d38cbca8de4983dc6">printVecASCII</a> (const Vec &amp;b, char const name[]=&quot;printVecASCII.txt&quot;, const PetscViewerFormat format=PETSC_VIEWER_DEFAULT)</td></tr>
<tr class="memdesc:a4364796301e74a3d38cbca8de4983dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">view Petsc Vec variable to ASCII file  <a href="#a4364796301e74a3d38cbca8de4983dc6">More...</a><br/></td></tr>
<tr class="separator:a4364796301e74a3d38cbca8de4983dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d76ae2d9866d1b8ed73be02db39e15"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#af0d76ae2d9866d1b8ed73be02db39e15">Read_q</a> (<a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data, char const buff[]=&quot;../OrrSommerfeld_and_primitive/uvwP_201&quot;)</td></tr>
<tr class="memdesc:af0d76ae2d9866d1b8ed73be02db39e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read q from a tofile output from python.  <a href="#af0d76ae2d9866d1b8ed73be02db39e15">More...</a><br/></td></tr>
<tr class="separator:af0d76ae2d9866d1b8ed73be02db39e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fdc0a1f5ad0fec1fdfe9a9c641427e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#aa9fdc0a1f5ad0fec1fdfe9a9c641427e">Read_q</a> (Vec &amp;output, const int n, char const buff[]=&quot;./src/tofile.dat&quot;)</td></tr>
<tr class="memdesc:aa9fdc0a1f5ad0fec1fdfe9a9c641427e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read q from a tofile output from python.  <a href="#aa9fdc0a1f5ad0fec1fdfe9a9c641427e">More...</a><br/></td></tr>
<tr class="separator:aa9fdc0a1f5ad0fec1fdfe9a9c641427e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1493d76919f4ea1d554af787837822a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a1493d76919f4ea1d554af787837822a4">Read_q</a> (PetscScalar output[], const int n, char const buff[]=&quot;./src/tofile.dat&quot;)</td></tr>
<tr class="memdesc:a1493d76919f4ea1d554af787837822a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read y from a tofile output from python.  <a href="#a1493d76919f4ea1d554af787837822a4">More...</a><br/></td></tr>
<tr class="separator:a1493d76919f4ea1d554af787837822a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8f33c751131e0b7bf9359f4929088d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#ace8f33c751131e0b7bf9359f4929088d">Read_q</a> (PetscScalar &amp;output, char const buff[]=&quot;./src/tofile.dat&quot;)</td></tr>
<tr class="memdesc:ace8f33c751131e0b7bf9359f4929088d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read complex scalar from a tofile output from python.  <a href="#ace8f33c751131e0b7bf9359f4929088d">More...</a><br/></td></tr>
<tr class="separator:ace8f33c751131e0b7bf9359f4929088d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5cd98e89da895591df9ccd077c2d50"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a4b5cd98e89da895591df9ccd077c2d50">set_A_and_B</a> (<a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data)</td></tr>
<tr class="memdesc:a4b5cd98e89da895591df9ccd077c2d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">set A and B matrix for <a class="el" href="namespacePSE.html">PSE</a> equations  <a href="#a4b5cd98e89da895591df9ccd077c2d50">More...</a><br/></td></tr>
<tr class="separator:a4b5cd98e89da895591df9ccd077c2d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e2d434c6cb2771fa23c67f18f6d29f"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a58e2d434c6cb2771fa23c67f18f6d29f">set_A_and_B_zi</a> (<a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data, const PetscInt &amp;zi=0)</td></tr>
<tr class="memdesc:a58e2d434c6cb2771fa23c67f18f6d29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">set A and B matrix for <a class="el" href="namespacePSE.html">PSE</a> equations for zi plane  <a href="#a58e2d434c6cb2771fa23c67f18f6d29f">More...</a><br/></td></tr>
<tr class="separator:a58e2d434c6cb2771fa23c67f18f6d29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2ed663ec0562dc6e5e1ac5f48e1428"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a1b2ed663ec0562dc6e5e1ac5f48e1428">set_b</a> (const Mat &amp;B, const Vec &amp;qn, Vec &amp;b)</td></tr>
<tr class="memdesc:a1b2ed663ec0562dc6e5e1ac5f48e1428"><td class="mdescLeft">&#160;</td><td class="mdescRight">set b vector from B and q as b=B*q  <a href="#a1b2ed663ec0562dc6e5e1ac5f48e1428">More...</a><br/></td></tr>
<tr class="separator:a1b2ed663ec0562dc6e5e1ac5f48e1428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f94bbe2f2fcbcdafc37ed00360ad86"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a80f94bbe2f2fcbcdafc37ed00360ad86">set_BCs</a> (Mat &amp;A, Vec &amp;b, const PetscInt &amp;ny, const PetscInt &amp;nz)</td></tr>
<tr class="memdesc:a80f94bbe2f2fcbcdafc37ed00360ad86"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets Boundary Condition equations in Matrix A and vector b in Ax=b linear system for solving the <a class="el" href="namespacePSE.html">PSE</a> equations  <a href="#a80f94bbe2f2fcbcdafc37ed00360ad86">More...</a><br/></td></tr>
<tr class="separator:a80f94bbe2f2fcbcdafc37ed00360ad86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05eaa365016721007dccbed624f65b62"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a05eaa365016721007dccbed624f65b62">set_BCs</a> (Mat &amp;A, Mat &amp;B, const PetscInt &amp;ny, const PetscInt &amp;nz)</td></tr>
<tr class="memdesc:a05eaa365016721007dccbed624f65b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets Boundary Condition equations in Matrix A and Matrix B in A+ B*dqdx=0 linear system for solving the <a class="el" href="namespacePSE.html">PSE</a> equations  <a href="#a05eaa365016721007dccbed624f65b62">More...</a><br/></td></tr>
<tr class="separator:a05eaa365016721007dccbed624f65b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1243b4f1e9b24d23fdb837af6bedcc16"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a1243b4f1e9b24d23fdb837af6bedcc16">set_D</a> (const PetscScalar y[], const PetscInt &amp;n, Mat &amp;output, <a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data, const PetscInt &amp;order=2, const PetscInt &amp;d=2, const PetscBool &amp;periodic=PETSC_FALSE, const PetscBool &amp;reduce_wall_order=PETSC_TRUE, const PetscBool &amp;uniform=PETSC_TRUE)</td></tr>
<tr class="memdesc:a1243b4f1e9b24d23fdb837af6bedcc16"><td class="mdescLeft">&#160;</td><td class="mdescRight">set D matrix operator for specified order and derivative  <a href="#a1243b4f1e9b24d23fdb837af6bedcc16">More...</a><br/></td></tr>
<tr class="separator:a1243b4f1e9b24d23fdb837af6bedcc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa7463fb62fd319d4b545923eed13fd"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a9fa7463fb62fd319d4b545923eed13fd">set_Euler_Advance</a> (const PetscScalar &amp;hx, Mat &amp;A, Mat &amp;B)</td></tr>
<tr class="memdesc:a9fa7463fb62fd319d4b545923eed13fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix multiplication for Euler stepping, A+= 1/hx * B and B*=1/hx  <a href="#a9fa7463fb62fd319d4b545923eed13fd">More...</a><br/></td></tr>
<tr class="separator:a9fa7463fb62fd319d4b545923eed13fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb460f33e3b6822bce281047b3f92df"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#aadb460f33e3b6822bce281047b3f92df">set_Mat</a> (const PetscScalar *const *Ain, const PetscInt &amp;n, Mat &amp;A, const InsertMode &amp;addv=ADD_VALUES)</td></tr>
<tr class="memdesc:aadb460f33e3b6822bce281047b3f92df"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a matrix from PetscScalar 2D matrix to PETSc Mat type in parallel  <a href="#aadb460f33e3b6822bce281047b3f92df">More...</a><br/></td></tr>
<tr class="separator:aadb460f33e3b6822bce281047b3f92df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6a03d71013c1832acb354e08eb4fa0"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a5a6a03d71013c1832acb354e08eb4fa0">set_Mat</a> (const PetscScalar &amp;diag, const PetscInt &amp;n, Mat &amp;A, const PetscInt &amp;k=0, const PetscBool &amp;parallel=PETSC_TRUE, const InsertMode &amp;addv=ADD_VALUES)</td></tr>
<tr class="memdesc:a5a6a03d71013c1832acb354e08eb4fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a diagonal of a matrix from scalar  <a href="#a5a6a03d71013c1832acb354e08eb4fa0">More...</a><br/></td></tr>
<tr class="separator:a5a6a03d71013c1832acb354e08eb4fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a665211c867a946e6c2c97fac8261f"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a40a665211c867a946e6c2c97fac8261f">set_Mat</a> (Mat &amp;A)</td></tr>
<tr class="memdesc:a40a665211c867a946e6c2c97fac8261f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble matrix.  <a href="#a40a665211c867a946e6c2c97fac8261f">More...</a><br/></td></tr>
<tr class="separator:a40a665211c867a946e6c2c97fac8261f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b30d081fb841dec74e4dae61b5e32bc"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a4b30d081fb841dec74e4dae61b5e32bc">set_Mat</a> (const PetscScalar &amp;value, const PetscInt &amp;row, const PetscInt &amp;col, Mat &amp;A, const PetscBool &amp;parallel=PETSC_TRUE, const InsertMode &amp;addv=ADD_VALUES)</td></tr>
<tr class="memdesc:a4b30d081fb841dec74e4dae61b5e32bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a single value in matrix at row,col  <a href="#a4b30d081fb841dec74e4dae61b5e32bc">More...</a><br/></td></tr>
<tr class="separator:a4b30d081fb841dec74e4dae61b5e32bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9459290168f207d9839bcde63e5a56a0"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a9459290168f207d9839bcde63e5a56a0">set_Mat</a> (const PetscScalar &amp;a, const Mat &amp;Asub, const PetscInt &amp;nsub, Mat &amp;A, const PetscInt &amp;n, const PetscInt &amp;rowoffset=0, const PetscInt &amp;coloffset=0, const InsertMode &amp;addv=ADD_VALUES)</td></tr>
<tr class="memdesc:a9459290168f207d9839bcde63e5a56a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a submatrix Asub in a matrix A  <a href="#a9459290168f207d9839bcde63e5a56a0">More...</a><br/></td></tr>
<tr class="separator:a9459290168f207d9839bcde63e5a56a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac507f97367f3c93c65edf8f0131552bb"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#ac507f97367f3c93c65edf8f0131552bb">set_Mat</a> (const PetscScalar *Ain, const PetscInt &amp;row, const PetscInt &amp;ncols, const PetscInt cols[], Mat &amp;A, const InsertMode &amp;addv=ADD_VALUES)</td></tr>
<tr class="memdesc:ac507f97367f3c93c65edf8f0131552bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a row of PetscScalar to a matrix to PETSc Mat  <a href="#ac507f97367f3c93c65edf8f0131552bb">More...</a><br/></td></tr>
<tr class="separator:ac507f97367f3c93c65edf8f0131552bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d79528f491c382f7a911667a1733b68"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a7d79528f491c382f7a911667a1733b68">set_Mat</a> (const PetscScalar &amp;a, const Mat &amp;Dz, const PetscInt &amp;nz, const PetscInt &amp;ny, const PetscInt &amp;zi, Mat &amp;A, const PetscInt &amp;n, const PetscInt &amp;rowoffset=0, const PetscInt &amp;coloffset=0, const InsertMode &amp;addv=ADD_VALUES)</td></tr>
<tr class="memdesc:a7d79528f491c382f7a911667a1733b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a Dz submatrix into A  <a href="#a7d79528f491c382f7a911667a1733b68">More...</a><br/></td></tr>
<tr class="separator:a7d79528f491c382f7a911667a1733b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2df7541e3595870bb4782d962de131"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a7f2df7541e3595870bb4782d962de131">set_MatDiagonalScale</a> (const Mat &amp;diag_to_scale, const Mat &amp;Asub, const PetscInt &amp;nsub, Mat &amp;A, const PetscInt &amp;n, const PetscInt &amp;rowoffset=0, const PetscInt &amp;coloffset=0, const InsertMode &amp;addv=ADD_VALUES)</td></tr>
<tr class="memdesc:a7f2df7541e3595870bb4782d962de131"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a scaled matrix, (rows are scaled by matrix, using A=LA and MatDiagonalScale)  <a href="#a7f2df7541e3595870bb4782d962de131">More...</a><br/></td></tr>
<tr class="separator:a7f2df7541e3595870bb4782d962de131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca217cde478d73b5469f46e51a48be9"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#aaca217cde478d73b5469f46e51a48be9">set_Mat_broadcast_from_colVec</a> (Vec &amp;x, PetscInt &amp;n, Mat &amp;A)</td></tr>
<tr class="memdesc:aaca217cde478d73b5469f46e51a48be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a matrix from a column vector (broadcast the column vector to all columns of a matrix Be sure that A is already initialized  <a href="#aaca217cde478d73b5469f46e51a48be9">More...</a><br/></td></tr>
<tr class="separator:aaca217cde478d73b5469f46e51a48be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6401d0b66259dc17e248b11ba8994c2"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#aa6401d0b66259dc17e248b11ba8994c2">set_Vec</a> (const PetscScalar *bin, const PetscInt &amp;n, Vec &amp;b, const PetscBool &amp;parallel=PETSC_TRUE)</td></tr>
<tr class="memdesc:aa6401d0b66259dc17e248b11ba8994c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a vector from PetscScalar 1D vector to PETSc Vec type in parallel  <a href="#aa6401d0b66259dc17e248b11ba8994c2">More...</a><br/></td></tr>
<tr class="separator:aa6401d0b66259dc17e248b11ba8994c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cf4be41ee60bc04f43dca61f15e0bf"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a21cf4be41ee60bc04f43dca61f15e0bf">set_Vec</a> (Vec &amp;b)</td></tr>
<tr class="memdesc:a21cf4be41ee60bc04f43dca61f15e0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble b vector.  <a href="#a21cf4be41ee60bc04f43dca61f15e0bf">More...</a><br/></td></tr>
<tr class="separator:a21cf4be41ee60bc04f43dca61f15e0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d517f522b7038fb21aded9c8113d49"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a67d517f522b7038fb21aded9c8113d49">set_Vec</a> (const PetscScalar &amp;bin, const PetscInt &amp;n, Vec &amp;b)</td></tr>
<tr class="memdesc:a67d517f522b7038fb21aded9c8113d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a vector from PetscScalar to PETSc Vec in location n  <a href="#a67d517f522b7038fb21aded9c8113d49">More...</a><br/></td></tr>
<tr class="separator:a67d517f522b7038fb21aded9c8113d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbaa2fa2002e60d96e1019140975e98"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#aadbaa2fa2002e60d96e1019140975e98">set_Vec</a> (const Vec &amp;inVec, const PetscInt &amp;low, const PetscInt &amp;hi, Vec &amp;b)</td></tr>
<tr class="memdesc:aadbaa2fa2002e60d96e1019140975e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a subvector from larger vector from low to hi indices  <a href="#aadbaa2fa2002e60d96e1019140975e98">More...</a><br/></td></tr>
<tr class="separator:aadbaa2fa2002e60d96e1019140975e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830c6be6ce992c9db886bc9afa8321d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a830c6be6ce992c9db886bc9afa8321d4">trapz</a> (const Vec &amp;q, PetscScalar &amp;I, <a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data)</td></tr>
<tr class="memdesc:a830c6be6ce992c9db886bc9afa8321d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">trapezoidal rule on Vec with ny,nz values  <a href="#a830c6be6ce992c9db886bc9afa8321d4">More...</a><br/></td></tr>
<tr class="separator:a830c6be6ce992c9db886bc9afa8321d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf103d5b2ebb63f164a5c3b26e91282"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#adaf103d5b2ebb63f164a5c3b26e91282">update_Closure</a> (PetscScalar &amp;Ialpha, const PetscScalar alpha_i, <a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data, int istep, const PetscReal &amp;tol=1e-15, const PetscInt &amp;maxiter=50)</td></tr>
<tr class="memdesc:adaf103d5b2ebb63f164a5c3b26e91282"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the closure equation \( \int_\Omega \hat{\textbf{q}}^\dagger \hat{\textbf{q}}_x dy \) and output the result This is part of the solution procedure shown in the bottom half of this diagram  <a href="#adaf103d5b2ebb63f164a5c3b26e91282">More...</a><br/></td></tr>
<tr class="separator:adaf103d5b2ebb63f164a5c3b26e91282"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ad8518bbf640f7df9a882d0f9d4f92d27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::_bblf </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>input</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar&#160;</td>
          <td class="paramname"><em>output</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blasius boundary layer function to integrate. Similarity Blasius ODE broken into three coupled equations </p>
<p class="formulaDsp">
\[ \begin{aligned} f&#39;&#39; &amp;= \int -ff&#39;&#39; d\eta\\ f&#39; &amp;= \int f&#39;&#39; d\eta\\ f &amp;= \int f&#39; d\eta\\ \end{aligned} \]
</p>
<p>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>\([f&#39;&#39;, f&#39;, f]\) state at \( \eta_i \) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>\([f&#39;&#39;, f&#39;, f]\) state at \(\eta_{i+1} \) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a34e5a20f5f1deeb44a0bb7b5c2ed9953"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::Ax_b </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar *const *&#160;</td>
          <td class="paramname"><em>Ain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>bin</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves \(x\) in \(Ax=b\) linalg problem using PETSc in parallel Useful for solving small systems of equations, such as finite difference coefficients for given stencils. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Ain</td><td>input of 2D \(A\) matrix in \(Ax=b\) (must be dynamic pointer to pointer) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>vector of \(x\) in \(Ax=b\) (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bin</td><td>vector of \(b\) in \(Ax=b\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>n size of vectors or nxn matrix \(A\) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a95785703297cd3c22a8ad3035ccb0d6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::Ax_b </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves \(x\) in \(Ax=b\) linalg problem using PETSc in parallel. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input of A matrix in \(Ax=b\) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>vector of \(x\) in \(Ax=b\) (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>vector of \(b\) in \(Ax=b\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>n size of vectors or nxn matrix \(A\) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7aefd0b610d54fee980cd1cd96daa41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::base_flow </td>
          <td>(</td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set plane channel flow velocity variables \(U, U_x, U_y,\) and etc  use this once to set the vectors with the velocity of plane channel flow (max u=1) </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data from class passed in and out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6b3cf1ddae425e811cf278753d2440e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::calc_Closure </td>
          <td>(</td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the closure equation \( \int_{\Omega} \hat{\textbf{q}}^\dagger \hat{\textbf{q}}_x dy \) and output the result </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>output integral value </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to store values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd6d3524c36acc4ba132b8051151ca97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned PSE::factorial </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the factorial of an integer </p>
<dl class="section return"><dt>Returns</dt><dd>n! </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">n</td><td>input integer to perform factorial on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf121ec8492dfe6fd8cde8b6b05aaa14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::get_D_Coeffs </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>s</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve arbitrary stencil points s of length N with order of derivatives d&lt;N can be obtained from equation on MIT website <a href="http://web.media.mit.edu/~crtaylor/calculator.html">http://web.media.mit.edu/~crtaylor/calculator.html</a> where the accuracy is determined as the usual form O(h^(N-d)) </p>
<p>ierr from Ax=b solver </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>array of stencil points e.g. [-3,-2,-1,0,1] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of stencil </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>output of coefficient values for the given stencil (uninitialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>order of desired derivative (default=2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a28bf5687be08e4dd183f9eff806487"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::Init_Mat </td>
          <td>(</td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a Matrix A to be of size nxn. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>A matrix to initialize in MPI (uninitialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of global rows and columns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc379863dab0514427427caf2889d23d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::Init_Mat </td>
          <td>(</td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a Matrix A to be of size mxn. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>A matrix to initialize in MPI (uninitialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of global rows </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of global columns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a929ef72234fddb31ff867fa1446a8905"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::Init_Vec </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a vector x to be of size n. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td>x vector to initialize in MPI (uninitialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad40bb9d0042e3aba3153311e517d8d3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::map_D </td>
          <td>(</td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>yVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>order</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscBool &amp;&#160;</td>
          <td class="paramname"><em>periodic</em> = <code>PETSC_FALSE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscBool &amp;&#160;</td>
          <td class="paramname"><em>reduce_wall_order</em> = <code>PETSC_TRUE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>map D matrix operator for specified order and derivative, for a non-uniform mesh </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">output</td><td>matrix(n by n) dth derivative of order O(h^order) assuming uniform xi spacing coming in (initialized), then output a non-uniform derivative w.r.t. y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data class to have flags </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>length of y values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yVec</td><td>y non-uniform data pts of interest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>order of accuracy desired (assuming even e.g. 2,4,6,...) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>dth derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">periodic</td><td>periodic boundary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reduce_wall_order</td><td>reduce the order of accuracy at the wall? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3da6b6642caa8372bbb1d60cac8d300d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscErrorCode PSE::printInt </td>
          <td>(</td>
          <td class="paramtype">const PetscInt&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>name</em>[] = <code>&quot;x&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print PetscInt variable to screen. </p>
<dl class="section return"><dt>Returns</dt><dd>ierr from PetscErrorCode of PetscPrintf </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>PetscScalar array to print to screen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of scalar array to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of variable to output default to 'x' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a805847775fb8d170ad2db3518044108b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PSE::printMatASCII </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>name</em>[] = <code>&quot;printMatASCII.txt&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscViewerFormat&#160;</td>
          <td class="paramname"><em>format</em> = <code>PETSC_VIEWER_DEFAULT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>view Petsc Mat variable to ASCII file </p>
<ul>
<li>Helpful runtime option:</li>
</ul>
<p>-draw_pause &lt;pause&gt; : sets time (in seconds) that the program pauses after PetscDrawPause() has been called (0 is default, -1 implies until user input). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Petsc Mat nxn matrix to print to screen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>filename to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>format for viewer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7733a43624f64edc21e21f0d611e300a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PSE::printMatGetDiagonalASCII </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>name</em>[] = <code>&quot;printMatGetDiagonalASCII.txt&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscViewerFormat&#160;</td>
          <td class="paramname"><em>format</em> = <code>PETSC_VIEWER_DEFAULT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>print diagonal of Petsc Mat variable to ASCII file </p>
<ul>
<li>Helpful runtime option:</li>
</ul>
<p>-draw_pause &lt;pause&gt; : sets time (in seconds) that the program pauses after PetscDrawPause() has been called (0 is default, -1 implies until user input). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Petsc Mat nxn matrix to print to screen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>filename to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>format for viewer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4eca5e043cde66f140837461b4b533c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PSE::printMatView </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>name</em>[] = <code>&quot;A&#160;viewer&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscViewerFormat&#160;</td>
          <td class="paramname"><em>format</em> = <code>PETSC_VIEWER_DEFAULT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>view Petsc Mat variable to screen Open an X-window viewer. Note that we specify the same communicator for the viewer as we used for the distributed vector (PETSC_COMM_WORLD). </p>
<ul>
<li>Helpful runtime option:</li>
</ul>
<p>-draw_pause &lt;pause&gt; : sets time (in seconds) that the program pauses after PetscDrawPause() has been called (0 is default, -1 implies until user input). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Petsc Mat nxn matrix to print to screen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of variable to output default to 'A' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>format for viewer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac456c4c880624b7a6b907995a05e9b48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscErrorCode PSE::printScalar </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>name</em>[] = <code>&quot;x&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscViewer&#160;</td>
          <td class="paramname"><em>viewer</em> = <code>PETSC_VIEWER_STDOUT_WORLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print PetscScalar variable to screen. </p>
<dl class="section return"><dt>Returns</dt><dd>ierr from PetscErrorCode of PetscPrintf </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>PetscScalar array to print to screen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of scalar array to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of variable to output default to 'x' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewer</td><td>format for viewer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a728ecf3fee73eeb301802d577abd31dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscErrorCode PSE::printVec </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>name</em>[] = <code>&quot;x&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print Vec from PETSc type variable to screen. </p>
<dl class="section return"><dt>Returns</dt><dd>ierr from PetscErrorCode of PetscPrintf </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Vec array to print to screen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of scalar array to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of variable to output default to 'x' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4364796301e74a3d38cbca8de4983dc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PSE::printVecASCII </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>name</em>[] = <code>&quot;printVecASCII.txt&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscViewerFormat&#160;</td>
          <td class="paramname"><em>format</em> = <code>PETSC_VIEWER_DEFAULT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>view Petsc Vec variable to ASCII file </p>
<ul>
<li>Helpful runtime option:</li>
</ul>
<p>-draw_pause &lt;pause&gt; : sets time (in seconds) that the program pauses after PetscDrawPause() has been called (0 is default, -1 implies until user input). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Petsc Vec 1xn vector to print to screen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>filename to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>format for viewer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adcd72375bfd6c3e459eec96fcc9fb25b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PSE::printVecView </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>name</em>[] = <code>&quot;x&#160;viewer&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscViewerFormat&#160;</td>
          <td class="paramname"><em>format</em> = <code>PETSC_VIEWER_DEFAULT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>view PetscVec variable to screen Open an X-window viewer. Note that we specify the same communicator for the viewer as we used for the distributed vector (PETSC_COMM_WORLD). </p>
<ul>
<li>Helpful runtime option:</li>
</ul>
<p>-draw_pause &lt;pause&gt; : sets time (in seconds) that the program pauses after PetscDrawPause() has been called (0 is default, -1 implies until user input). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>PetscScalar array to print to screen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of variable to output default to 'x' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>format for viewer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0d76ae2d9866d1b8ed73be02db39e15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::Read_q </td>
          <td>(</td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>buff</em>[] = <code>&quot;../OrrSommerfeld_and_primitive/uvwP_201&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read q from a tofile output from python. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to hold data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>filename of binary to read (output of python script </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa9fdc0a1f5ad0fec1fdfe9a9c641427e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::Read_q </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>buff</em>[] = <code>&quot;./src/tofile.dat&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read q from a tofile output from python. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">output</td><td>vector to return after reading file (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>int size of vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>filename of binary to read (output of python script </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1493d76919f4ea1d554af787837822a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::Read_q </td>
          <td>(</td>
          <td class="paramtype">PetscScalar&#160;</td>
          <td class="paramname"><em>output</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>buff</em>[] = <code>&quot;./src/tofile.dat&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read y from a tofile output from python. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>vector to return after reading file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>int size of vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>filename of binary to read (output of python script </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace8f33c751131e0b7bf9359f4929088d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::Read_q </td>
          <td>(</td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>buff</em>[] = <code>&quot;./src/tofile.dat&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read complex scalar from a tofile output from python. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>complex scalar to return after reading file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>filename of binary to read (output of python script </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b5cd98e89da895591df9ccd077c2d50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_A_and_B </td>
          <td>(</td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set A and B matrix for <a class="el" href="namespacePSE.html">PSE</a> equations </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>data class containing all matrices, vectors, scalars, and problem size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a58e2d434c6cb2771fa23c67f18f6d29f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_A_and_B_zi </td>
          <td>(</td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>zi</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set A and B matrix for <a class="el" href="namespacePSE.html">PSE</a> equations for zi plane </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to store values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zi</td><td>zi plane of matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b2ed663ec0562dc6e5e1ac5f48e1428"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_b </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>qn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set b vector from B and q as b=B*q </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>B matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qn</td><td>qn vector to multiply </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>b Vec (already initialized) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80f94bbe2f2fcbcdafc37ed00360ad86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_BCs </td>
          <td>(</td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>nz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets Boundary Condition equations in Matrix A and vector b in Ax=b linear system for solving the <a class="el" href="namespacePSE.html">PSE</a> equations </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>A matrix (already initialized) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>b Vec (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ny</td><td>size of y array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nz</td><td>size of z array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a05eaa365016721007dccbed624f65b62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_BCs </td>
          <td>(</td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>nz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets Boundary Condition equations in Matrix A and Matrix B in A+ B*dqdx=0 linear system for solving the <a class="el" href="namespacePSE.html">PSE</a> equations </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>A matrix (already initialized) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td>B Matrix (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ny</td><td>size of y array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nz</td><td>size of z array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1243b4f1e9b24d23fdb837af6bedcc16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_D </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>y</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>order</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscBool &amp;&#160;</td>
          <td class="paramname"><em>periodic</em> = <code>PETSC_FALSE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscBool &amp;&#160;</td>
          <td class="paramname"><em>reduce_wall_order</em> = <code>PETSC_TRUE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscBool &amp;&#160;</td>
          <td class="paramname"><em>uniform</em> = <code>PETSC_TRUE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set D matrix operator for specified order and derivative </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>array of y values of channel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>length of y values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>matrix(n by n) dth derivative of order O(h^order) assuming uniform y spacing (uninitialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data class to have flags </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>order of accuracy desired (assuming even e.g. 2,4,6,...) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>dth derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">periodic</td><td>periodic boundary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reduce_wall_order</td><td>reduce the order of accuracy at the wall? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uniform</td><td>uniform mesh? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9fa7463fb62fd319d4b545923eed13fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Euler_Advance </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>hx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>matrix multiplication for Euler stepping, A+= 1/hx * B and B*=1/hx </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hx</td><td>delta x distance </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>A matrix set from set_A_and_B (already initialized) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td>B matrix set from set_A_and_B (already initialized) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aadb460f33e3b6822bce281047b3f92df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Mat </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar *const *&#160;</td>
          <td class="paramname"><em>Ain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InsertMode &amp;&#160;</td>
          <td class="paramname"><em>addv</em> = <code>ADD_VALUES</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a matrix from PetscScalar 2D matrix to PETSc Mat type in parallel </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Ain</td><td>Matrix set on all processors as 2D array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of nxn matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>Mat to SetValues and output in parallel (uninitialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addv</td><td>insert values or add values to matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a6a03d71013c1832acb354e08eb4fa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Mat </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscBool &amp;&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>PETSC_TRUE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InsertMode &amp;&#160;</td>
          <td class="paramname"><em>addv</em> = <code>ADD_VALUES</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a diagonal of a matrix from scalar </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">diag</td><td>scalar value to set as diagonal in matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of nxn matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Mat to SetValues and output in parallel (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>diagonal offset in matrix (k=0 is main diagonal, k&gt;0 is above main diagonal, k&lt;0 is below main diagonal) default is 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parallel</td><td>set the matrix using Istart and Iend </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addv</td><td>insert values or add values to matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40a665211c867a946e6c2c97fac8261f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Mat </td>
          <td>(</td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Mat to assemble (already initialized) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b30d081fb841dec74e4dae61b5e32bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Mat </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscBool &amp;&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>PETSC_TRUE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InsertMode &amp;&#160;</td>
          <td class="paramname"><em>addv</em> = <code>ADD_VALUES</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a single value in matrix at row,col </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>value to set in Mat A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>specified global row in Mat A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>specified global col in Mat A </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Matrix A to set value (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parallel</td><td>do this in parallel? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addv</td><td>insert values or add values to matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9459290168f207d9839bcde63e5a56a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Mat </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>Asub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>nsub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>rowoffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>coloffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InsertMode &amp;&#160;</td>
          <td class="paramname"><em>addv</em> = <code>ADD_VALUES</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a submatrix Asub in a matrix A </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>premultple to Asub </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Asub</td><td>sub matrix to set into mat </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nsub</td><td>nxn size of square sub matrix Asub </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Matrix A to set value (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of square Matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowoffset</td><td>start inserting Asub in A starting at rowoffset row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coloffset</td><td>start inserting Asub in A starting at coloffset column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addv</td><td>insert values or add values to matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac507f97367f3c93c65edf8f0131552bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Mat </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar *&#160;</td>
          <td class="paramname"><em>Ain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt&#160;</td>
          <td class="paramname"><em>cols</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InsertMode &amp;&#160;</td>
          <td class="paramname"><em>addv</em> = <code>ADD_VALUES</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a row of PetscScalar to a matrix to PETSc Mat </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Ain</td><td>array to set in row of matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>row to set in matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ncols</td><td>ncols of array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cols</td><td>cols to set in matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Mat to SetValues and output in parallel (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addv</td><td>insert values or add values to matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d79528f491c382f7a911667a1733b68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Mat </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>Dz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>zi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>rowoffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>coloffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InsertMode &amp;&#160;</td>
          <td class="paramname"><em>addv</em> = <code>ADD_VALUES</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a Dz submatrix into A </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>premultple to Dz </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Dz</td><td>sub matrix to set into mat in z direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nz</td><td>nzxnz size of square sub matrix Dz </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ny</td><td>length of y array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zi</td><td>which z plane you are looking at </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Matrix A to set value (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of square Matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowoffset</td><td>start inserting Asub in A starting at rowoffset row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coloffset</td><td>start inserting Asub in A starting at coloffset column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addv</td><td>insert values or add values to matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaca217cde478d73b5469f46e51a48be9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Mat_broadcast_from_colVec </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a matrix from a column vector (broadcast the column vector to all columns of a matrix Be sure that A is already initialized </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>column Vec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>lenght of Vec </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>Matrix of size nxn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f2df7541e3595870bb4782d962de131"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_MatDiagonalScale </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>diag_to_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>Asub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>nsub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>rowoffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>coloffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InsertMode &amp;&#160;</td>
          <td class="paramname"><em>addv</em> = <code>ADD_VALUES</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a scaled matrix, (rows are scaled by matrix, using A=LA and MatDiagonalScale) </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">diag_to_scale</td><td>premultple to scale the rows of Asub </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Asub</td><td>sub matrix to set into mat </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nsub</td><td>nxn size of square sub matrix Asub </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Matrix A to set value (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of square Matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowoffset</td><td>start inserting Asub in A starting at rowoffset row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coloffset</td><td>start inserting Asub in A starting at coloffset column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addv</td><td>insert values or add values to matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6401d0b66259dc17e248b11ba8994c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Vec </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar *&#160;</td>
          <td class="paramname"><em>bin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscBool &amp;&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>PETSC_TRUE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a vector from PetscScalar 1D vector to PETSc Vec type in parallel </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bin</td><td>array set on all processors as 1D array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of n array </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>Vec to SetValues and output in parallel (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parallel</td><td>set in parallel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a21cf4be41ee60bc04f43dca61f15e0bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Vec </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble b vector. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>array to assemble on all processors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67d517f522b7038fb21aded9c8113d49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Vec </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>bin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a vector from PetscScalar to PETSc Vec in location n </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bin</td><td>scalar to set into Vec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>location to put into Vec </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>Vec to SetValues (already initialized) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aadbaa2fa2002e60d96e1019140975e98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Vec </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>inVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a subvector from larger vector from low to hi indices </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inVec</td><td>larger vec to copy values from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">low</td><td>lower bound </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hi</td><td>upper bound </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>Vec to SetValues and output (already initialized) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a830c6be6ce992c9db886bc9afa8321d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::trapz </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>trapezoidal rule on Vec with ny,nz values </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>Vector to integrate </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>value of integration </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>data class to store Trapzy and Trapzz value and flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adaf103d5b2ebb63f164a5c3b26e91282"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::update_Closure </td>
          <td>(</td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>Ialpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>alpha_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>istep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscReal &amp;&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code>50</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the closure equation \( \int_\Omega \hat{\textbf{q}}^\dagger \hat{\textbf{q}}_x dy \) and output the result This is part of the solution procedure shown in the bottom half of this diagram </p>
<div class="image">
<img src="Diagram_closure.png" alt="Diagram_closure.png"/>
<div class="caption">
Solution Procedure</div></div>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Ialpha</td><td>integral value from previous step \( \int_0^{x_i} \alpha(\xi) d\xi \) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha_i</td><td>initial alpha value of eigenfunction (constant from last step initially) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to store values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">istep</td><td>update step (for outputting filenames) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>tolerance on norm equation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxiter</td><td>maximum number of iterations (not implimented) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
