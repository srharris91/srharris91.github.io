<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>PSE Project: PSE Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PSE Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">PSE Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPSE_1_1PSE.html">PSE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to contain various variables for <a class="el" href="classPSE_1_1PSE.html" title="Class to contain various variables for PSE solution. ">PSE</a> solution.  <a href="classPSE_1_1PSE.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a34e5a20f5f1deeb44a0bb7b5c2ed9953"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a34e5a20f5f1deeb44a0bb7b5c2ed9953">Ax_b</a> (const PetscScalar *const *Ain, Vec &amp;x, const PetscScalar bin[], const PetscInt &amp;n)</td></tr>
<tr class="memdesc:a34e5a20f5f1deeb44a0bb7b5c2ed9953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves \(x\) in \(Ax=b\) linalg problem using PETSc in parallel Useful for solving small systems of equations, such as finite difference coefficients for given stencils.  <a href="#a34e5a20f5f1deeb44a0bb7b5c2ed9953">More...</a><br/></td></tr>
<tr class="separator:a34e5a20f5f1deeb44a0bb7b5c2ed9953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95785703297cd3c22a8ad3035ccb0d6f"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a95785703297cd3c22a8ad3035ccb0d6f">Ax_b</a> (const Mat &amp;A, Vec &amp;x, const Vec &amp;b, const PetscInt &amp;n)</td></tr>
<tr class="memdesc:a95785703297cd3c22a8ad3035ccb0d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves \(x\) in \(Ax=b\) linalg problem using PETSc in parallel.  <a href="#a95785703297cd3c22a8ad3035ccb0d6f">More...</a><br/></td></tr>
<tr class="separator:a95785703297cd3c22a8ad3035ccb0d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2962deb8a0be0527a99952ee6c70f04"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#ae2962deb8a0be0527a99952ee6c70f04">Ax_kBx</a> (const Mat &amp;A, const Mat &amp;B, PetscScalar &amp;kr, PetscScalar &amp;ki, Vec &amp;xr, Vec &amp;xi, PetscScalar target=0.54213+0.082968 *PETSC_i, PetscInt nev=1, EPSWhich which=EPS_TARGET_MAGNITUDE)</td></tr>
<tr class="memdesc:ae2962deb8a0be0527a99952ee6c70f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves \(x\) in \(Ax=kBx\) eigenvalue problem using SLEPc in parallel.  <a href="#ae2962deb8a0be0527a99952ee6c70f04">More...</a><br/></td></tr>
<tr class="separator:ae2962deb8a0be0527a99952ee6c70f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7aefd0b610d54fee980cd1cd96daa41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#ae7aefd0b610d54fee980cd1cd96daa41">base_flow</a> (<a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data)</td></tr>
<tr class="memdesc:ae7aefd0b610d54fee980cd1cd96daa41"><td class="mdescLeft">&#160;</td><td class="mdescRight">set plane channel or blasius boundary layer flow velocity variables \(U, U_x, U_y,\) and etc  use this once to set the vectors with the velocity of plane channel flow (max u=1)  <a href="#ae7aefd0b610d54fee980cd1cd96daa41">More...</a><br/></td></tr>
<tr class="separator:ae7aefd0b610d54fee980cd1cd96daa41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8518bbf640f7df9a882d0f9d4f92d27"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#ad8518bbf640f7df9a882d0f9d4f92d27">_bblf</a> (const PetscScalar input[3], PetscScalar output[3])</td></tr>
<tr class="memdesc:ad8518bbf640f7df9a882d0f9d4f92d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blasius boundary layer function to integrate. Similarity Blasius ODE broken into three coupled equations </p>
<p class="formulaDsp">
\[ \begin{aligned} f&#39;&#39; &amp;= \int -ff&#39;&#39; d\eta\\ f&#39; &amp;= \int f&#39;&#39; d\eta\\ f &amp;= \int f&#39; d\eta\\ \end{aligned} \]
</p>
<p>.  <a href="#ad8518bbf640f7df9a882d0f9d4f92d27">More...</a><br/></td></tr>
<tr class="separator:ad8518bbf640f7df9a882d0f9d4f92d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14b9fc2858d4f98c1df1198e7c40b00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#ad14b9fc2858d4f98c1df1198e7c40b00">calc_Closure</a> (PetscScalar &amp;I, <a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data, Vec &amp;q, Vec &amp;qp1)</td></tr>
<tr class="memdesc:ad14b9fc2858d4f98c1df1198e7c40b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the closure equation \( \int_{\Omega} \hat{\textbf{q}}^\dagger \hat{\textbf{q}}_x dy \) and output the result  <a href="#ad14b9fc2858d4f98c1df1198e7c40b00">More...</a><br/></td></tr>
<tr class="separator:ad14b9fc2858d4f98c1df1198e7c40b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611b399ebda39dbf48643d3620bf8180"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a611b399ebda39dbf48643d3620bf8180">calc_L2</a> (PetscReal &amp;error, Vec &amp;x1, Vec &amp;x2, PetscInt n, NormType type=NORM_2)</td></tr>
<tr class="memdesc:a611b399ebda39dbf48643d3620bf8180"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the \( L_2 \) norm of the difference between x1 and x2 vectors and return  <a href="#a611b399ebda39dbf48643d3620bf8180">More...</a><br/></td></tr>
<tr class="separator:a611b399ebda39dbf48643d3620bf8180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fc663e63ff83eed663a2e99c70559a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a67fc663e63ff83eed663a2e99c70559a">calc_LST</a> (<a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data, PetscScalar target_alpha, PetscScalar &amp;alpha, Vec &amp;qp1_OSS, Vec &amp;qp1)</td></tr>
<tr class="memdesc:a67fc663e63ff83eed663a2e99c70559a"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the Local Stability Theory (LST) Orr-Sommerfeld Squire equations in primitive variables at this x-location and store the alpha and qp1 of the target spatial values.  <a href="#a67fc663e63ff83eed663a2e99c70559a">More...</a><br/></td></tr>
<tr class="separator:a67fc663e63ff83eed663a2e99c70559a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37c47da094495b1ef751d210b41f4c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#ac37c47da094495b1ef751d210b41f4c5">Create_grid</a> (<a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data, PetscScalar deltay=0.)</td></tr>
<tr class="memdesc:ac37c47da094495b1ef751d210b41f4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">create y and z grid and stretch in y direction using stretching if deltay is nonzero  <a href="#ac37c47da094495b1ef751d210b41f4c5">More...</a><br/></td></tr>
<tr class="separator:ac37c47da094495b1ef751d210b41f4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6d3524c36acc4ba132b8051151ca97"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#afd6d3524c36acc4ba132b8051151ca97">factorial</a> (unsigned n)</td></tr>
<tr class="memdesc:afd6d3524c36acc4ba132b8051151ca97"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the factorial of an integer  <a href="#afd6d3524c36acc4ba132b8051151ca97">More...</a><br/></td></tr>
<tr class="separator:afd6d3524c36acc4ba132b8051151ca97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf121ec8492dfe6fd8cde8b6b05aaa14"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#aaf121ec8492dfe6fd8cde8b6b05aaa14">get_D_Coeffs</a> (const PetscScalar s[], const PetscInt &amp;n, Vec &amp;output, const PetscInt &amp;d=2)</td></tr>
<tr class="memdesc:aaf121ec8492dfe6fd8cde8b6b05aaa14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve arbitrary stencil points s of length N with order of derivatives d&lt;N can be obtained from equation on MIT website <a href="http://web.media.mit.edu/~crtaylor/calculator.html">http://web.media.mit.edu/~crtaylor/calculator.html</a> where the accuracy is determined as the usual form O(h^(N-d))  <a href="#aaf121ec8492dfe6fd8cde8b6b05aaa14">More...</a><br/></td></tr>
<tr class="separator:aaf121ec8492dfe6fd8cde8b6b05aaa14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a28bf5687be08e4dd183f9eff806487"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a6a28bf5687be08e4dd183f9eff806487">Init_Mat</a> (Mat &amp;A, const PetscInt &amp;n)</td></tr>
<tr class="memdesc:a6a28bf5687be08e4dd183f9eff806487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a Matrix A to be of size nxn.  <a href="#a6a28bf5687be08e4dd183f9eff806487">More...</a><br/></td></tr>
<tr class="separator:a6a28bf5687be08e4dd183f9eff806487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc379863dab0514427427caf2889d23d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#acc379863dab0514427427caf2889d23d">Init_Mat</a> (Mat &amp;A, const PetscInt &amp;m, const PetscInt &amp;n)</td></tr>
<tr class="memdesc:acc379863dab0514427427caf2889d23d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a Matrix A to be of size mxn.  <a href="#acc379863dab0514427427caf2889d23d">More...</a><br/></td></tr>
<tr class="separator:acc379863dab0514427427caf2889d23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929ef72234fddb31ff867fa1446a8905"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a929ef72234fddb31ff867fa1446a8905">Init_Vec</a> (Vec &amp;x, const PetscInt &amp;n)</td></tr>
<tr class="memdesc:a929ef72234fddb31ff867fa1446a8905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a vector x to be of size n.  <a href="#a929ef72234fddb31ff867fa1446a8905">More...</a><br/></td></tr>
<tr class="separator:a929ef72234fddb31ff867fa1446a8905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40bb9d0042e3aba3153311e517d8d3b"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#ad40bb9d0042e3aba3153311e517d8d3b">map_D</a> (Mat &amp;output, <a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data, const PetscInt &amp;n, Vec &amp;yVec, const PetscInt &amp;order=2, const PetscInt &amp;d=2, const PetscBool &amp;periodic=PETSC_FALSE, const PetscBool &amp;reduce_wall_order=PETSC_TRUE)</td></tr>
<tr class="memdesc:ad40bb9d0042e3aba3153311e517d8d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">map D matrix operator for specified order and derivative, for a non-uniform mesh  <a href="#ad40bb9d0042e3aba3153311e517d8d3b">More...</a><br/></td></tr>
<tr class="separator:ad40bb9d0042e3aba3153311e517d8d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac456c4c880624b7a6b907995a05e9b48"><td class="memItemLeft" align="right" valign="top">PetscErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#ac456c4c880624b7a6b907995a05e9b48">printScalar</a> (const PetscScalar x[], const PetscInt n=1, char const name[]=&quot;x&quot;, const PetscViewer viewer=PETSC_VIEWER_STDOUT_WORLD)</td></tr>
<tr class="memdesc:ac456c4c880624b7a6b907995a05e9b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print PetscScalar variable to screen.  <a href="#ac456c4c880624b7a6b907995a05e9b48">More...</a><br/></td></tr>
<tr class="separator:ac456c4c880624b7a6b907995a05e9b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728ecf3fee73eeb301802d577abd31dc"><td class="memItemLeft" align="right" valign="top">PetscErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a728ecf3fee73eeb301802d577abd31dc">printVec</a> (const Vec &amp;x, const PetscInt n, char const name[]=&quot;x&quot;)</td></tr>
<tr class="memdesc:a728ecf3fee73eeb301802d577abd31dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print Vec from PETSc type variable to screen.  <a href="#a728ecf3fee73eeb301802d577abd31dc">More...</a><br/></td></tr>
<tr class="separator:a728ecf3fee73eeb301802d577abd31dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da6b6642caa8372bbb1d60cac8d300d"><td class="memItemLeft" align="right" valign="top">PetscErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a3da6b6642caa8372bbb1d60cac8d300d">printInt</a> (const PetscInt x[], const PetscInt n=1, char const name[]=&quot;x&quot;)</td></tr>
<tr class="memdesc:a3da6b6642caa8372bbb1d60cac8d300d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print PetscInt variable to screen.  <a href="#a3da6b6642caa8372bbb1d60cac8d300d">More...</a><br/></td></tr>
<tr class="separator:a3da6b6642caa8372bbb1d60cac8d300d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd72375bfd6c3e459eec96fcc9fb25b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#adcd72375bfd6c3e459eec96fcc9fb25b">printVecView</a> (const Vec &amp;x, char const name[]=&quot;x viewer&quot;, const PetscViewerFormat format=PETSC_VIEWER_DEFAULT)</td></tr>
<tr class="memdesc:adcd72375bfd6c3e459eec96fcc9fb25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">view PetscVec variable to screen Open an X-window viewer. Note that we specify the same communicator for the viewer as we used for the distributed vector (PETSC_COMM_WORLD).  <a href="#adcd72375bfd6c3e459eec96fcc9fb25b">More...</a><br/></td></tr>
<tr class="separator:adcd72375bfd6c3e459eec96fcc9fb25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eca5e043cde66f140837461b4b533c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a4eca5e043cde66f140837461b4b533c5">printMatView</a> (const Mat &amp;A, char const name[]=&quot;A viewer&quot;, const PetscViewerFormat format=PETSC_VIEWER_DEFAULT)</td></tr>
<tr class="memdesc:a4eca5e043cde66f140837461b4b533c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">view Petsc Mat variable to screen Open an X-window viewer. Note that we specify the same communicator for the viewer as we used for the distributed vector (PETSC_COMM_WORLD).  <a href="#a4eca5e043cde66f140837461b4b533c5">More...</a><br/></td></tr>
<tr class="separator:a4eca5e043cde66f140837461b4b533c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805847775fb8d170ad2db3518044108b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a805847775fb8d170ad2db3518044108b">printMatASCII</a> (const Mat &amp;A, char const name[]=&quot;printMatASCII.txt&quot;, const PetscViewerFormat format=PETSC_VIEWER_DEFAULT)</td></tr>
<tr class="memdesc:a805847775fb8d170ad2db3518044108b"><td class="mdescLeft">&#160;</td><td class="mdescRight">view Petsc Mat variable to ASCII file  <a href="#a805847775fb8d170ad2db3518044108b">More...</a><br/></td></tr>
<tr class="separator:a805847775fb8d170ad2db3518044108b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7733a43624f64edc21e21f0d611e300a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a7733a43624f64edc21e21f0d611e300a">printMatGetDiagonalASCII</a> (const Mat &amp;A, char const name[]=&quot;printMatGetDiagonalASCII.txt&quot;, const PetscViewerFormat format=PETSC_VIEWER_DEFAULT)</td></tr>
<tr class="memdesc:a7733a43624f64edc21e21f0d611e300a"><td class="mdescLeft">&#160;</td><td class="mdescRight">print diagonal of Petsc Mat variable to ASCII file  <a href="#a7733a43624f64edc21e21f0d611e300a">More...</a><br/></td></tr>
<tr class="separator:a7733a43624f64edc21e21f0d611e300a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4364796301e74a3d38cbca8de4983dc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a4364796301e74a3d38cbca8de4983dc6">printVecASCII</a> (const Vec &amp;b, char const name[]=&quot;printVecASCII.txt&quot;, const PetscViewerFormat format=PETSC_VIEWER_DEFAULT)</td></tr>
<tr class="memdesc:a4364796301e74a3d38cbca8de4983dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">view Petsc Vec variable to ASCII file  <a href="#a4364796301e74a3d38cbca8de4983dc6">More...</a><br/></td></tr>
<tr class="separator:a4364796301e74a3d38cbca8de4983dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2bc7ed1e79fe8308ef56823913bb19"><td class="memItemLeft" align="right" valign="top">PetscErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#aba2bc7ed1e79fe8308ef56823913bb19">printClosureIter</a> (<a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data)</td></tr>
<tr class="memdesc:aba2bc7ed1e79fe8308ef56823913bb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">print iteration residuals to screen from update_Closure iterations  <a href="#aba2bc7ed1e79fe8308ef56823913bb19">More...</a><br/></td></tr>
<tr class="separator:aba2bc7ed1e79fe8308ef56823913bb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ccac638f68601a696d48fc7ea63daa"><td class="memItemLeft" align="right" valign="top">PetscErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a76ccac638f68601a696d48fc7ea63daa">printNonlinearIter</a> (<a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data)</td></tr>
<tr class="memdesc:a76ccac638f68601a696d48fc7ea63daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">print iteration residuals to screen from update_Nonlinear iterations  <a href="#a76ccac638f68601a696d48fc7ea63daa">More...</a><br/></td></tr>
<tr class="separator:a76ccac638f68601a696d48fc7ea63daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbb9b8b23e4c512603ffeb968425d20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#addbb9b8b23e4c512603ffeb968425d20">printHeaderIter</a> ()</td></tr>
<tr class="memdesc:addbb9b8b23e4c512603ffeb968425d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">print iteration residuals header to screen  <a href="#addbb9b8b23e4c512603ffeb968425d20">More...</a><br/></td></tr>
<tr class="separator:addbb9b8b23e4c512603ffeb968425d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5be5daaa46471496c89223afe91a5a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#ab5be5daaa46471496c89223afe91a5a6">Read_input_file</a> (<a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data, char const buff[]=&quot;input_file.json&quot;)</td></tr>
<tr class="memdesc:ab5be5daaa46471496c89223afe91a5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an input file written in json format.  <a href="#ab5be5daaa46471496c89223afe91a5a6">More...</a><br/></td></tr>
<tr class="separator:ab5be5daaa46471496c89223afe91a5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0dd2b21db657dd50257c0eca0621db3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#aa0dd2b21db657dd50257c0eca0621db3">set_input_value</a> (Json::Value &amp;val, const char buff[], PetscInt &amp;v)</td></tr>
<tr class="memdesc:aa0dd2b21db657dd50257c0eca0621db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">take Json data and save it to value if it exists  <a href="#aa0dd2b21db657dd50257c0eca0621db3">More...</a><br/></td></tr>
<tr class="separator:aa0dd2b21db657dd50257c0eca0621db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa3487090c04d91a14cd606793f431f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a4aa3487090c04d91a14cd606793f431f">set_input_value</a> (Json::Value &amp;val, const char buff[], PetscReal &amp;v)</td></tr>
<tr class="memdesc:a4aa3487090c04d91a14cd606793f431f"><td class="mdescLeft">&#160;</td><td class="mdescRight">take Json data and save it to value if it exists  <a href="#a4aa3487090c04d91a14cd606793f431f">More...</a><br/></td></tr>
<tr class="separator:a4aa3487090c04d91a14cd606793f431f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f625fe247533b74e528da7ea7e601c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a0f625fe247533b74e528da7ea7e601c5">set_input_value</a> (Json::Value &amp;val, const char buff[], PetscScalar &amp;v)</td></tr>
<tr class="memdesc:a0f625fe247533b74e528da7ea7e601c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">take Json data and save it to value if it exists  <a href="#a0f625fe247533b74e528da7ea7e601c5">More...</a><br/></td></tr>
<tr class="separator:a0f625fe247533b74e528da7ea7e601c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711aa62ae6bd4437389d7d3583215722"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a711aa62ae6bd4437389d7d3583215722">set_input_value</a> (Json::Value &amp;val, const char buff[], PetscBool &amp;v)</td></tr>
<tr class="memdesc:a711aa62ae6bd4437389d7d3583215722"><td class="mdescLeft">&#160;</td><td class="mdescRight">take Json data and save it to value if it exists  <a href="#a711aa62ae6bd4437389d7d3583215722">More...</a><br/></td></tr>
<tr class="separator:a711aa62ae6bd4437389d7d3583215722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5f51e6045ce513b3cd96c63df07e8d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#abf5f51e6045ce513b3cd96c63df07e8d">set_input_value</a> (Json::Value &amp;val, const char buff[], char *v)</td></tr>
<tr class="memdesc:abf5f51e6045ce513b3cd96c63df07e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">take Json data and save it to value if it exists  <a href="#abf5f51e6045ce513b3cd96c63df07e8d">More...</a><br/></td></tr>
<tr class="separator:abf5f51e6045ce513b3cd96c63df07e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d1706451068d94665d452c3d61b2f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#aa6d1706451068d94665d452c3d61b2f1">set_input_value</a> (Json::Value &amp;val, const char buff[], std::string &amp;v)</td></tr>
<tr class="memdesc:aa6d1706451068d94665d452c3d61b2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">take Json data and save it to value if it exists  <a href="#aa6d1706451068d94665d452c3d61b2f1">More...</a><br/></td></tr>
<tr class="separator:aa6d1706451068d94665d452c3d61b2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784a766a2f191bcdb42518a4054350c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a784a766a2f191bcdb42518a4054350c8">Read_q</a> (<a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data, std::string &amp;buff)</td></tr>
<tr class="memdesc:a784a766a2f191bcdb42518a4054350c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read q from a tofile output from python.  <a href="#a784a766a2f191bcdb42518a4054350c8">More...</a><br/></td></tr>
<tr class="separator:a784a766a2f191bcdb42518a4054350c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00269ce280ff26c0efe6bf05eafc6d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#aa00269ce280ff26c0efe6bf05eafc6d1">Read_q</a> (Vec &amp;output, const int n, std::string &amp;buff)</td></tr>
<tr class="memdesc:aa00269ce280ff26c0efe6bf05eafc6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read q from a tofile output from python.  <a href="#aa00269ce280ff26c0efe6bf05eafc6d1">More...</a><br/></td></tr>
<tr class="separator:aa00269ce280ff26c0efe6bf05eafc6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a16b0ae4a9f35cb44644b0b9fb8ce7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a0a16b0ae4a9f35cb44644b0b9fb8ce7f">Read_q</a> (PetscScalar output[], const int n, std::string &amp;buff)</td></tr>
<tr class="memdesc:a0a16b0ae4a9f35cb44644b0b9fb8ce7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read y from a tofile output from python.  <a href="#a0a16b0ae4a9f35cb44644b0b9fb8ce7f">More...</a><br/></td></tr>
<tr class="separator:a0a16b0ae4a9f35cb44644b0b9fb8ce7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adebd5af66cc444f85082dae836c24ee0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#adebd5af66cc444f85082dae836c24ee0">Read_q</a> (PetscScalar &amp;output, std::string &amp;buff)</td></tr>
<tr class="memdesc:adebd5af66cc444f85082dae836c24ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read complex scalar from a tofile output from python.  <a href="#adebd5af66cc444f85082dae836c24ee0">More...</a><br/></td></tr>
<tr class="separator:adebd5af66cc444f85082dae836c24ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b961f444d5cc8a19d2ea6c466c26cc"><td class="memItemLeft" align="right" valign="top">PetscErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#ae5b961f444d5cc8a19d2ea6c466c26cc">Read_MatLabVec</a> (Vec &amp;output, std::string &amp;buff)</td></tr>
<tr class="memdesc:ae5b961f444d5cc8a19d2ea6c466c26cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read complex scalar vector from a matlab file (be sure this uses the PetscBinaryWrite() MatLab function)  <a href="#ae5b961f444d5cc8a19d2ea6c466c26cc">More...</a><br/></td></tr>
<tr class="separator:ae5b961f444d5cc8a19d2ea6c466c26cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fecf23dc69ac871eefb7efdedbae0e"><td class="memItemLeft" align="right" valign="top">PetscErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a48fecf23dc69ac871eefb7efdedbae0e">Read_MatLabMat</a> (Mat &amp;output, std::string &amp;buff)</td></tr>
<tr class="memdesc:a48fecf23dc69ac871eefb7efdedbae0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read complex scalar matrix from a matlab file (be sure this uses the PetscBinaryWrite() MatLab function)  <a href="#a48fecf23dc69ac871eefb7efdedbae0e">More...</a><br/></td></tr>
<tr class="separator:a48fecf23dc69ac871eefb7efdedbae0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d16ac83d532b86b8963e79437bbd76"><td class="memItemLeft" align="right" valign="top">PetscErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a28d16ac83d532b86b8963e79437bbd76">Read_MatLab</a> (<a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data, std::string &amp;buff)</td></tr>
<tr class="memdesc:a28d16ac83d532b86b8963e79437bbd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read input matrix and vectors input data from a matlab files (be sure this uses the PetscBinaryWrite() MatLab function) Reads and sets y, yVec, z, zVec, q, qp1, alpha, Deltay, and Deltaz quantities in the <a class="el" href="namespacePSE.html">PSE</a> class.  <a href="#a28d16ac83d532b86b8963e79437bbd76">More...</a><br/></td></tr>
<tr class="separator:a28d16ac83d532b86b8963e79437bbd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d5b769d9c0425545e1701eaa181e2e"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#ab7d5b769d9c0425545e1701eaa181e2e">set_A_and_B_OSS_zi</a> (<a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data, const PetscInt &amp;zi=0)</td></tr>
<tr class="memdesc:ab7d5b769d9c0425545e1701eaa181e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">set A and B matrix for Orr-Sommerfeld equations for zi plane Note that the wavelike ansatz is \(u=\hat{u}(y,z) \exp (i (-\omega t + \alpha x))\) </p>
<p class="formulaDsp">
\[ \begin{aligned} (-i \omega - \frac{1}{Re}(\partial_y^2 + \partial_z^2))\hat{u} + U&#39; \hat{v} &amp;= \alpha (-i \hat{P} - \frac{i}{Re}(\partial_y \hat{v} + \partial_z \hat{w}) - iU \hat{u})\\ (-i \omega - \frac{1}{Re}(\partial_y^2 + \partial_z^2))\hat{v} + \partial_y \hat{P} &amp;= \alpha (- \frac{1}{Re}(\alpha \hat{v}) - iU \hat{v})\\ (\alpha \hat{v}) &amp;= \alpha \cdot \hat{v}\\ (-i \omega - \frac{1}{Re}(\partial_y^2 + \partial_z^2))\hat{w} + \partial_z \hat{P} &amp;= \alpha (- \frac{1}{Re}(\alpha \hat{w}) - iU \hat{w})\\ (\alpha \hat{w}) &amp;= \alpha \cdot \hat{w}\\ \partial_y \hat{v} + \partial_z \hat{w} &amp;= \alpha (-i \hat{u})\\ \end{aligned}\]
</p>
<p> Where we have </p>
<p class="formulaDsp">
\[ \begin{aligned} \mathbf{z}_i= \begin{bmatrix} \hat{u}\\ \alpha \hat{v}\\ \hat{v}\\ \alpha \hat{w}\\ \hat{w}\\ \hat{P} \end{bmatrix}_{z=z(i)} \textrm{ and } &amp; \mathbf{q} = \begin{bmatrix} \mathbf{z}_1\\ \mathbf{z}_2\\ \vdots \\ \mathbf{z}_{nz - 1}\\ \mathbf{z}_{nz}\\ \end{bmatrix}\\ \end{aligned}\]
</p>
<p> To solve the spatial eigenvalue problem \(\mathbf{\mathcal{A}q} = \alpha \mathbf{\mathcal{B}q}\)  <a href="#ab7d5b769d9c0425545e1701eaa181e2e">More...</a><br/></td></tr>
<tr class="separator:ab7d5b769d9c0425545e1701eaa181e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03a89105e706fa67f7cd042c76a1be6"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#aa03a89105e706fa67f7cd042c76a1be6">set_A_and_Ds</a> (<a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data, PetscScalar &amp;alpha)</td></tr>
<tr class="memdesc:aa03a89105e706fa67f7cd042c76a1be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">set A and B matrix for <a class="el" href="namespacePSE.html">PSE</a> equations  <a href="#aa03a89105e706fa67f7cd042c76a1be6">More...</a><br/></td></tr>
<tr class="separator:aa03a89105e706fa67f7cd042c76a1be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb30fb64d89502daeceb49f296c48de"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#aeeb30fb64d89502daeceb49f296c48de">set_A_and_Ds_nonlinear</a> (<a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data)</td></tr>
<tr class="memdesc:aeeb30fb64d89502daeceb49f296c48de"><td class="mdescLeft">&#160;</td><td class="mdescRight">set A and D matrix linear terms for <a class="el" href="namespacePSE.html">PSE</a> equations for nonlinear terms  <a href="#aeeb30fb64d89502daeceb49f296c48de">More...</a><br/></td></tr>
<tr class="separator:aeeb30fb64d89502daeceb49f296c48de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef0799fa0695c45ee5d5d66f4da8289"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a8ef0799fa0695c45ee5d5d66f4da8289">set_A_and_Ds_zi</a> (<a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data, PetscScalar &amp;alpha, const PetscInt &amp;zi=0)</td></tr>
<tr class="memdesc:a8ef0799fa0695c45ee5d5d66f4da8289"><td class="mdescLeft">&#160;</td><td class="mdescRight">set A and B matrix linear terms for <a class="el" href="namespacePSE.html">PSE</a> equations for zi plane (also sets the permutation matrices to extract u from q, etc.  <a href="#a8ef0799fa0695c45ee5d5d66f4da8289">More...</a><br/></td></tr>
<tr class="separator:a8ef0799fa0695c45ee5d5d66f4da8289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2ed663ec0562dc6e5e1ac5f48e1428"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a1b2ed663ec0562dc6e5e1ac5f48e1428">set_b</a> (const Mat &amp;B, const Vec &amp;qn, Vec &amp;b)</td></tr>
<tr class="memdesc:a1b2ed663ec0562dc6e5e1ac5f48e1428"><td class="mdescLeft">&#160;</td><td class="mdescRight">set b vector from B and q as b=B*q  <a href="#a1b2ed663ec0562dc6e5e1ac5f48e1428">More...</a><br/></td></tr>
<tr class="separator:a1b2ed663ec0562dc6e5e1ac5f48e1428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f94bbe2f2fcbcdafc37ed00360ad86"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a80f94bbe2f2fcbcdafc37ed00360ad86">set_BCs</a> (Mat &amp;A, Vec &amp;b, const PetscInt &amp;ny, const PetscInt &amp;nz)</td></tr>
<tr class="memdesc:a80f94bbe2f2fcbcdafc37ed00360ad86"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets Boundary Condition equations in Matrix A and vector b in Ax=b linear system for solving the <a class="el" href="namespacePSE.html">PSE</a> equations  <a href="#a80f94bbe2f2fcbcdafc37ed00360ad86">More...</a><br/></td></tr>
<tr class="separator:a80f94bbe2f2fcbcdafc37ed00360ad86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04e24f274b343e927d35d88c1c51804"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#aa04e24f274b343e927d35d88c1c51804">set_BCs</a> (<a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data)</td></tr>
<tr class="memdesc:aa04e24f274b343e927d35d88c1c51804"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets Boundary Condition equations in Matrix A and Matrix B in A+ B*dqdx=0 linear system for solving the <a class="el" href="namespacePSE.html">PSE</a> equations  <a href="#aa04e24f274b343e927d35d88c1c51804">More...</a><br/></td></tr>
<tr class="separator:aa04e24f274b343e927d35d88c1c51804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d814d4df74ea2faf8d09fd55227c0b"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#af3d814d4df74ea2faf8d09fd55227c0b">set_Crank_Nicolson_Advance</a> (<a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data, Vec &amp;q, PetscScalar &amp;alpha)</td></tr>
<tr class="memdesc:af3d814d4df74ea2faf8d09fd55227c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">set up Crank-Nicolson advancing matrices A x = b system by creating matrices and setting BCs  <a href="#af3d814d4df74ea2faf8d09fd55227c0b">More...</a><br/></td></tr>
<tr class="separator:af3d814d4df74ea2faf8d09fd55227c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1243b4f1e9b24d23fdb837af6bedcc16"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a1243b4f1e9b24d23fdb837af6bedcc16">set_D</a> (const PetscScalar y[], const PetscInt &amp;n, Mat &amp;output, <a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data, const PetscInt &amp;order=2, const PetscInt &amp;d=2, const PetscBool &amp;periodic=PETSC_FALSE, const PetscBool &amp;reduce_wall_order=PETSC_TRUE, const PetscBool &amp;uniform=PETSC_TRUE)</td></tr>
<tr class="memdesc:a1243b4f1e9b24d23fdb837af6bedcc16"><td class="mdescLeft">&#160;</td><td class="mdescRight">set D matrix operator for specified order and derivative  <a href="#a1243b4f1e9b24d23fdb837af6bedcc16">More...</a><br/></td></tr>
<tr class="separator:a1243b4f1e9b24d23fdb837af6bedcc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfaa7ccc0701dca9c473434a9a83778"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#addfaa7ccc0701dca9c473434a9a83778">set_Euler_Advance</a> (<a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data, Vec &amp;q, PetscScalar &amp;alpha)</td></tr>
<tr class="memdesc:addfaa7ccc0701dca9c473434a9a83778"><td class="mdescLeft">&#160;</td><td class="mdescRight">set up Euler advancing matrices A x = b system by creating matrices and setting BCs  <a href="#addfaa7ccc0701dca9c473434a9a83778">More...</a><br/></td></tr>
<tr class="separator:addfaa7ccc0701dca9c473434a9a83778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb460f33e3b6822bce281047b3f92df"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#aadb460f33e3b6822bce281047b3f92df">set_Mat</a> (const PetscScalar *const *Ain, const PetscInt &amp;n, Mat &amp;A, const InsertMode &amp;addv=ADD_VALUES)</td></tr>
<tr class="memdesc:aadb460f33e3b6822bce281047b3f92df"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a matrix from PetscScalar 2D matrix to PETSc Mat type in parallel  <a href="#aadb460f33e3b6822bce281047b3f92df">More...</a><br/></td></tr>
<tr class="separator:aadb460f33e3b6822bce281047b3f92df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6a03d71013c1832acb354e08eb4fa0"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a5a6a03d71013c1832acb354e08eb4fa0">set_Mat</a> (const PetscScalar &amp;diag, const PetscInt &amp;n, Mat &amp;A, const PetscInt &amp;k=0, const PetscBool &amp;parallel=PETSC_TRUE, const InsertMode &amp;addv=ADD_VALUES)</td></tr>
<tr class="memdesc:a5a6a03d71013c1832acb354e08eb4fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a diagonal of a matrix from scalar  <a href="#a5a6a03d71013c1832acb354e08eb4fa0">More...</a><br/></td></tr>
<tr class="separator:a5a6a03d71013c1832acb354e08eb4fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a665211c867a946e6c2c97fac8261f"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a40a665211c867a946e6c2c97fac8261f">set_Mat</a> (Mat &amp;A)</td></tr>
<tr class="memdesc:a40a665211c867a946e6c2c97fac8261f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble matrix.  <a href="#a40a665211c867a946e6c2c97fac8261f">More...</a><br/></td></tr>
<tr class="separator:a40a665211c867a946e6c2c97fac8261f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b30d081fb841dec74e4dae61b5e32bc"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a4b30d081fb841dec74e4dae61b5e32bc">set_Mat</a> (const PetscScalar &amp;value, const PetscInt &amp;row, const PetscInt &amp;col, Mat &amp;A, const PetscBool &amp;parallel=PETSC_TRUE, const InsertMode &amp;addv=ADD_VALUES)</td></tr>
<tr class="memdesc:a4b30d081fb841dec74e4dae61b5e32bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a single value in matrix at row,col  <a href="#a4b30d081fb841dec74e4dae61b5e32bc">More...</a><br/></td></tr>
<tr class="separator:a4b30d081fb841dec74e4dae61b5e32bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9459290168f207d9839bcde63e5a56a0"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a9459290168f207d9839bcde63e5a56a0">set_Mat</a> (const PetscScalar &amp;a, const Mat &amp;Asub, const PetscInt &amp;nsub, Mat &amp;A, const PetscInt &amp;n, const PetscInt &amp;rowoffset=0, const PetscInt &amp;coloffset=0, const InsertMode &amp;addv=ADD_VALUES)</td></tr>
<tr class="memdesc:a9459290168f207d9839bcde63e5a56a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a submatrix Asub in a matrix A  <a href="#a9459290168f207d9839bcde63e5a56a0">More...</a><br/></td></tr>
<tr class="separator:a9459290168f207d9839bcde63e5a56a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac507f97367f3c93c65edf8f0131552bb"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#ac507f97367f3c93c65edf8f0131552bb">set_Mat</a> (const PetscScalar *Ain, const PetscInt &amp;row, const PetscInt &amp;ncols, const PetscInt cols[], Mat &amp;A, const InsertMode &amp;addv=ADD_VALUES)</td></tr>
<tr class="memdesc:ac507f97367f3c93c65edf8f0131552bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a row of PetscScalar to a matrix to PETSc Mat  <a href="#ac507f97367f3c93c65edf8f0131552bb">More...</a><br/></td></tr>
<tr class="separator:ac507f97367f3c93c65edf8f0131552bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dce2e6e9dbd48dd8e89f43ec4ac98d1"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a6dce2e6e9dbd48dd8e89f43ec4ac98d1">set_Mat</a> (const PetscScalar &amp;a, const Mat &amp;Dz, const PetscInt &amp;nz, const PetscInt &amp;ny, const PetscInt &amp;zi, Mat &amp;A, const PetscInt &amp;n, const PetscInt &amp;nvars=4, const PetscInt &amp;rowoffset=0, const PetscInt &amp;coloffset=0, const InsertMode &amp;addv=ADD_VALUES)</td></tr>
<tr class="memdesc:a6dce2e6e9dbd48dd8e89f43ec4ac98d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a Dz submatrix into A  <a href="#a6dce2e6e9dbd48dd8e89f43ec4ac98d1">More...</a><br/></td></tr>
<tr class="separator:a6dce2e6e9dbd48dd8e89f43ec4ac98d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2df7541e3595870bb4782d962de131"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a7f2df7541e3595870bb4782d962de131">set_MatDiagonalScale</a> (const Mat &amp;diag_to_scale, const Mat &amp;Asub, const PetscInt &amp;nsub, Mat &amp;A, const PetscInt &amp;n, const PetscInt &amp;rowoffset=0, const PetscInt &amp;coloffset=0, const InsertMode &amp;addv=ADD_VALUES)</td></tr>
<tr class="memdesc:a7f2df7541e3595870bb4782d962de131"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a scaled matrix, (rows are scaled by matrix, using A=LA and MatDiagonalScale)  <a href="#a7f2df7541e3595870bb4782d962de131">More...</a><br/></td></tr>
<tr class="separator:a7f2df7541e3595870bb4782d962de131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca217cde478d73b5469f46e51a48be9"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#aaca217cde478d73b5469f46e51a48be9">set_Mat_broadcast_from_colVec</a> (Vec &amp;x, PetscInt &amp;n, Mat &amp;A)</td></tr>
<tr class="memdesc:aaca217cde478d73b5469f46e51a48be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a matrix from a column vector (broadcast the column vector to all columns of a matrix Be sure that A is already initialized  <a href="#aaca217cde478d73b5469f46e51a48be9">More...</a><br/></td></tr>
<tr class="separator:aaca217cde478d73b5469f46e51a48be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82823d0901aa0c7d667a8f02379cf50"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#aa82823d0901aa0c7d667a8f02379cf50">set_Mat_from_Vec</a> (Vec &amp;x, PetscInt &amp;ny, PetscInt &amp;nz, PetscInt &amp;rowoffset, Mat &amp;A, const InsertMode &amp;addv=ADD_VALUES)</td></tr>
<tr class="memdesc:aa82823d0901aa0c7d667a8f02379cf50"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a matrix A (large ny*nz*4) from a vector (ny*nz) (used in the diagonals) at a certain rowoffset (between 0-ny*3). Be sure that A is already initialized  <a href="#aa82823d0901aa0c7d667a8f02379cf50">More...</a><br/></td></tr>
<tr class="separator:aa82823d0901aa0c7d667a8f02379cf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571185db1144849b1bf9f27e4dd9c3be"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a571185db1144849b1bf9f27e4dd9c3be">set_Mat_from_bf_Dy</a> (Vec &amp;bf, PetscInt &amp;ny, PetscInt &amp;nz, Mat &amp;Dy, Mat *P_bfnyi_from_bfnynz, Mat *bfDy)</td></tr>
<tr class="memdesc:a571185db1144849b1bf9f27e4dd9c3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">set an array of Matrices bfDy of array length nz and each Mat size of ny x ny from a vector bf (ny*nz) MatMatMult multiplied by Dy Be sure that each array Mat of bfDy is already initialized, and bf and Dy are already created with values  <a href="#a571185db1144849b1bf9f27e4dd9c3be">More...</a><br/></td></tr>
<tr class="separator:a571185db1144849b1bf9f27e4dd9c3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7af3dc32aff4e33533b8595ad7ab555"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#ae7af3dc32aff4e33533b8595ad7ab555">set_Mat_from_ef_Dz</a> (Vec &amp;ef, PetscInt &amp;ny, PetscInt &amp;nz, Mat &amp;Dz, Mat *P_efnzi_from_efnynz, Mat *efDz)</td></tr>
<tr class="memdesc:ae7af3dc32aff4e33533b8595ad7ab555"><td class="mdescLeft">&#160;</td><td class="mdescRight">set an array of Matrices efDz of array length ny and each Mat size of nz x nz from a vector ef (ny*nz) MatMatMult multiplied by Dz Be sure that each array Mat of efDz is already initialized, and ef and Dz are already created with values  <a href="#ae7af3dc32aff4e33533b8595ad7ab555">More...</a><br/></td></tr>
<tr class="separator:ae7af3dc32aff4e33533b8595ad7ab555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fea93f0b43d3be5d423ab9259b42935"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a5fea93f0b43d3be5d423ab9259b42935">set_Mat_efDz_into_A</a> (const PetscScalar &amp;a, const Mat *efDz, const PetscInt &amp;nz, const PetscInt &amp;yi, const PetscInt &amp;zi, Mat &amp;A, const PetscInt &amp;n, const PetscInt &amp;nvars=4, const PetscInt &amp;rowoffset=0, const PetscInt &amp;coloffset=0, const InsertMode &amp;addv=ADD_VALUES)</td></tr>
<tr class="memdesc:a5fea93f0b43d3be5d423ab9259b42935"><td class="mdescLeft">&#160;</td><td class="mdescRight">set an array of Matrices efDz of array length ny and each Mat size of nz x nz into the large A matrix of size 4*ny*nz This must be called for each ny,nz point to set the efDz into the correct spots in A  <a href="#a5fea93f0b43d3be5d423ab9259b42935">More...</a><br/></td></tr>
<tr class="separator:a5fea93f0b43d3be5d423ab9259b42935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6401d0b66259dc17e248b11ba8994c2"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#aa6401d0b66259dc17e248b11ba8994c2">set_Vec</a> (const PetscScalar *bin, const PetscInt &amp;n, Vec &amp;b, const PetscBool &amp;parallel=PETSC_TRUE)</td></tr>
<tr class="memdesc:aa6401d0b66259dc17e248b11ba8994c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a vector from PetscScalar 1D vector to PETSc Vec type in parallel  <a href="#aa6401d0b66259dc17e248b11ba8994c2">More...</a><br/></td></tr>
<tr class="separator:aa6401d0b66259dc17e248b11ba8994c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cf4be41ee60bc04f43dca61f15e0bf"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a21cf4be41ee60bc04f43dca61f15e0bf">set_Vec</a> (Vec &amp;b)</td></tr>
<tr class="memdesc:a21cf4be41ee60bc04f43dca61f15e0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble b vector.  <a href="#a21cf4be41ee60bc04f43dca61f15e0bf">More...</a><br/></td></tr>
<tr class="separator:a21cf4be41ee60bc04f43dca61f15e0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d517f522b7038fb21aded9c8113d49"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a67d517f522b7038fb21aded9c8113d49">set_Vec</a> (const PetscScalar &amp;bin, const PetscInt &amp;n, Vec &amp;b)</td></tr>
<tr class="memdesc:a67d517f522b7038fb21aded9c8113d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a vector from PetscScalar to PETSc Vec in location n  <a href="#a67d517f522b7038fb21aded9c8113d49">More...</a><br/></td></tr>
<tr class="separator:a67d517f522b7038fb21aded9c8113d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbaa2fa2002e60d96e1019140975e98"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#aadbaa2fa2002e60d96e1019140975e98">set_Vec</a> (const Vec &amp;inVec, const PetscInt &amp;low, const PetscInt &amp;hi, Vec &amp;b)</td></tr>
<tr class="memdesc:aadbaa2fa2002e60d96e1019140975e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a subvector from larger vector from low to hi indices  <a href="#aadbaa2fa2002e60d96e1019140975e98">More...</a><br/></td></tr>
<tr class="separator:aadbaa2fa2002e60d96e1019140975e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830c6be6ce992c9db886bc9afa8321d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a830c6be6ce992c9db886bc9afa8321d4">trapz</a> (const Vec &amp;q, PetscScalar &amp;I, <a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data)</td></tr>
<tr class="memdesc:a830c6be6ce992c9db886bc9afa8321d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">trapezoidal rule on Vec with ny,nz values  <a href="#a830c6be6ce992c9db886bc9afa8321d4">More...</a><br/></td></tr>
<tr class="separator:a830c6be6ce992c9db886bc9afa8321d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d6a319bd35d2b3b49f35b53b06db28"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a00d6a319bd35d2b3b49f35b53b06db28">update_Closure</a> (<a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data, Vec &amp;q, Vec &amp;qp1, PetscScalar &amp;alpha, const PetscInt &amp;maxiter=50)</td></tr>
<tr class="memdesc:a00d6a319bd35d2b3b49f35b53b06db28"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the closure equation \( \int_\Omega \hat{\textbf{q}}^\dagger \hat{\textbf{q}}_x dy \) and output the result This is part of the solution procedure shown in the bottom half of this diagram  <style>div.image img[src="SolutionProcedure.png"]{width:8.5in;}</style>   <a href="#a00d6a319bd35d2b3b49f35b53b06db28">More...</a><br/></td></tr>
<tr class="separator:a00d6a319bd35d2b3b49f35b53b06db28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f68cc4e295b911e3dedd896a9d7ca5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePSE.html#a18f68cc4e295b911e3dedd896a9d7ca5">update_Nonlinear</a> (<a class="el" href="classPSE_1_1PSE.html">PSE</a> &amp;data, Vec &amp;q, Vec &amp;qp1, PetscScalar &amp;alpha_old, PetscScalar &amp;alpha, PetscScalar &amp;Ialpha_old, PetscScalar &amp;Ialpha, const PetscInt &amp;maxiter=50)</td></tr>
<tr class="memdesc:a18f68cc4e295b911e3dedd896a9d7ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">advance the Nonlinear <a class="el" href="namespacePSE.html">PSE</a> system one x step  <a href="#a18f68cc4e295b911e3dedd896a9d7ca5">More...</a><br/></td></tr>
<tr class="separator:a18f68cc4e295b911e3dedd896a9d7ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ad8518bbf640f7df9a882d0f9d4f92d27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::_bblf </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>input</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar&#160;</td>
          <td class="paramname"><em>output</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blasius boundary layer function to integrate. Similarity Blasius ODE broken into three coupled equations </p>
<p class="formulaDsp">
\[ \begin{aligned} f&#39;&#39; &amp;= \int -ff&#39;&#39; d\eta\\ f&#39; &amp;= \int f&#39;&#39; d\eta\\ f &amp;= \int f&#39; d\eta\\ \end{aligned} \]
</p>
<p>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>\([f&#39;&#39;, f&#39;, f]\) state at \( \eta_i \) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>\([f&#39;&#39;, f&#39;, f]\) state at \(\eta_{i+1} \) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a34e5a20f5f1deeb44a0bb7b5c2ed9953"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::Ax_b </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar *const *&#160;</td>
          <td class="paramname"><em>Ain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>bin</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves \(x\) in \(Ax=b\) linalg problem using PETSc in parallel Useful for solving small systems of equations, such as finite difference coefficients for given stencils. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Ain</td><td>input of 2D \(A\) matrix in \(Ax=b\) (must be dynamic pointer to pointer) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>vector of \(x\) in \(Ax=b\) (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bin</td><td>vector of \(b\) in \(Ax=b\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>n size of vectors or nxn matrix \(A\) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a95785703297cd3c22a8ad3035ccb0d6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::Ax_b </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves \(x\) in \(Ax=b\) linalg problem using PETSc in parallel. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input of A matrix in \(Ax=b\) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>vector of \(x\) in \(Ax=b\) (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>vector of \(b\) in \(Ax=b\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>n size of vectors or nxn matrix \(A\) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae2962deb8a0be0527a99952ee6c70f04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::Ax_kBx </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>kr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>ki</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>xr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar&#160;</td>
          <td class="paramname"><em>target</em> = <code>0.54213+0.082968*PETSC_i</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscInt&#160;</td>
          <td class="paramname"><em>nev</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EPSWhich&#160;</td>
          <td class="paramname"><em>which</em> = <code>EPS_TARGET_MAGNITUDE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves \(x\) in \(Ax=kBx\) eigenvalue problem using SLEPc in parallel. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input of A matrix in \(Ax=kBx\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>input of B matrix in \(Ax=kBx\) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">kr</td><td>real part of eigenvalue </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ki</td><td>imag part of eigenvalue </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xr</td><td>vector of \(x\) in \(Ax=kBx\) (already initialized) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xi</td><td>vector of \(x\) in \(Ax=kBx\) (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>target eigenvalue to solve around using the which parameter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nev</td><td>number of eigenvalues to compute </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">which</td><td>portion of spectrum to be sought </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7aefd0b610d54fee980cd1cd96daa41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::base_flow </td>
          <td>(</td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set plane channel or blasius boundary layer flow velocity variables \(U, U_x, U_y,\) and etc  use this once to set the vectors with the velocity of plane channel flow (max u=1) </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data from class passed in and out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad14b9fc2858d4f98c1df1198e7c40b00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::calc_Closure </td>
          <td>(</td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>qp1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the closure equation \( \int_{\Omega} \hat{\textbf{q}}^\dagger \hat{\textbf{q}}_x dy \) and output the result </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>output integral value </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to store values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>q at last marching step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qp1</td><td>q at current marching step </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a611b399ebda39dbf48643d3620bf8180"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::calc_L2 </td>
          <td>(</td>
          <td class="paramtype">PetscReal &amp;&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscInt&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NormType&#160;</td>
          <td class="paramname"><em>type</em> = <code>NORM_2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the \( L_2 \) norm of the difference between x1 and x2 vectors and return </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">error</td><td>L2 norm of the difference between x1 and x2 vectors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x1</td><td>x1 vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x2</td><td>x2 vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of vectors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>type of norm (default NORM_2 sqrt(sum(|x1-x2|^2)) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67fc663e63ff83eed663a2e99c70559a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::calc_LST </td>
          <td>(</td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar&#160;</td>
          <td class="paramname"><em>target_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>qp1_OSS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>qp1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the Local Stability Theory (LST) Orr-Sommerfeld Squire equations in primitive variables at this x-location and store the alpha and qp1 of the target spatial values. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="set__A__and__B__OSS__zi_8hpp.html">set_A_and_B_OSS_zi.hpp</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to store values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_alpha</td><td>target alpha guess </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">alpha</td><td>alpha from OSS solver </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qp1_OSS</td><td>eigenvector of size data.dimOSS </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qp1</td><td>eigenvector of size data.dim </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac37c47da094495b1ef751d210b41f4c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::Create_grid </td>
          <td>(</td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar&#160;</td>
          <td class="paramname"><em>deltay</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create y and z grid and stretch in y direction using stretching if deltay is nonzero </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to hold data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deltay</td><td>stretching in y direction using hyperbolic stretching function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd6d3524c36acc4ba132b8051151ca97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned PSE::factorial </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the factorial of an integer </p>
<dl class="section return"><dt>Returns</dt><dd>n! </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">n</td><td>input integer to perform factorial on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf121ec8492dfe6fd8cde8b6b05aaa14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::get_D_Coeffs </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>s</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve arbitrary stencil points s of length N with order of derivatives d&lt;N can be obtained from equation on MIT website <a href="http://web.media.mit.edu/~crtaylor/calculator.html">http://web.media.mit.edu/~crtaylor/calculator.html</a> where the accuracy is determined as the usual form O(h^(N-d)) </p>
<p>ierr from Ax=b solver </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>array of stencil points e.g. [-3,-2,-1,0,1] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of stencil </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>output of coefficient values for the given stencil (uninitialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>order of desired derivative (default=2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a28bf5687be08e4dd183f9eff806487"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::Init_Mat </td>
          <td>(</td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a Matrix A to be of size nxn. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>A matrix to initialize in MPI (uninitialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of global rows and columns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc379863dab0514427427caf2889d23d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::Init_Mat </td>
          <td>(</td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a Matrix A to be of size mxn. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>A matrix to initialize in MPI (uninitialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of global rows </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of global columns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a929ef72234fddb31ff867fa1446a8905"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::Init_Vec </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a vector x to be of size n. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td>x vector to initialize in MPI (uninitialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad40bb9d0042e3aba3153311e517d8d3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::map_D </td>
          <td>(</td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>yVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>order</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscBool &amp;&#160;</td>
          <td class="paramname"><em>periodic</em> = <code>PETSC_FALSE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscBool &amp;&#160;</td>
          <td class="paramname"><em>reduce_wall_order</em> = <code>PETSC_TRUE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>map D matrix operator for specified order and derivative, for a non-uniform mesh </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">output</td><td>matrix(n by n) dth derivative of order O(h^order) assuming uniform xi spacing coming in (initialized), then output a non-uniform derivative w.r.t. y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data class to have flags </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>length of y values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yVec</td><td>y non-uniform data pts of interest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>order of accuracy desired (assuming even e.g. 2,4,6,...) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>dth derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">periodic</td><td>periodic boundary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reduce_wall_order</td><td>reduce the order of accuracy at the wall? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba2bc7ed1e79fe8308ef56823913bb19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscErrorCode PSE::printClosureIter </td>
          <td>(</td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>print iteration residuals to screen from update_Closure iterations </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data class storing iterations and residual values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="addbb9b8b23e4c512603ffeb968425d20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PSE::printHeaderIter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>print iteration residuals header to screen </p>

</div>
</div>
<a class="anchor" id="a3da6b6642caa8372bbb1d60cac8d300d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscErrorCode PSE::printInt </td>
          <td>(</td>
          <td class="paramtype">const PetscInt&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>name</em>[] = <code>&quot;x&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print PetscInt variable to screen. </p>
<dl class="section return"><dt>Returns</dt><dd>ierr from PetscErrorCode of PetscPrintf </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>PetscScalar array to print to screen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of scalar array to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of variable to output default to 'x' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a805847775fb8d170ad2db3518044108b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PSE::printMatASCII </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>name</em>[] = <code>&quot;printMatASCII.txt&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscViewerFormat&#160;</td>
          <td class="paramname"><em>format</em> = <code>PETSC_VIEWER_DEFAULT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>view Petsc Mat variable to ASCII file </p>
<ul>
<li>Helpful runtime option:</li>
</ul>
<p>-draw_pause &lt;pause&gt; : sets time (in seconds) that the program pauses after PetscDrawPause() has been called (0 is default, -1 implies until user input). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Petsc Mat nxn matrix to print to screen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>filename to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>format for viewer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7733a43624f64edc21e21f0d611e300a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PSE::printMatGetDiagonalASCII </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>name</em>[] = <code>&quot;printMatGetDiagonalASCII.txt&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscViewerFormat&#160;</td>
          <td class="paramname"><em>format</em> = <code>PETSC_VIEWER_DEFAULT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>print diagonal of Petsc Mat variable to ASCII file </p>
<ul>
<li>Helpful runtime option:</li>
</ul>
<p>-draw_pause &lt;pause&gt; : sets time (in seconds) that the program pauses after PetscDrawPause() has been called (0 is default, -1 implies until user input). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Petsc Mat nxn matrix to print to screen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>filename to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>format for viewer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4eca5e043cde66f140837461b4b533c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PSE::printMatView </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>name</em>[] = <code>&quot;A&#160;viewer&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscViewerFormat&#160;</td>
          <td class="paramname"><em>format</em> = <code>PETSC_VIEWER_DEFAULT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>view Petsc Mat variable to screen Open an X-window viewer. Note that we specify the same communicator for the viewer as we used for the distributed vector (PETSC_COMM_WORLD). </p>
<ul>
<li>Helpful runtime option:</li>
</ul>
<p>-draw_pause &lt;pause&gt; : sets time (in seconds) that the program pauses after PetscDrawPause() has been called (0 is default, -1 implies until user input). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Petsc Mat nxn matrix to print to screen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of variable to output default to 'A' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>format for viewer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a76ccac638f68601a696d48fc7ea63daa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscErrorCode PSE::printNonlinearIter </td>
          <td>(</td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>print iteration residuals to screen from update_Nonlinear iterations </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data class storing iterations and residual values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac456c4c880624b7a6b907995a05e9b48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscErrorCode PSE::printScalar </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>name</em>[] = <code>&quot;x&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscViewer&#160;</td>
          <td class="paramname"><em>viewer</em> = <code>PETSC_VIEWER_STDOUT_WORLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print PetscScalar variable to screen. </p>
<dl class="section return"><dt>Returns</dt><dd>ierr from PetscErrorCode of PetscPrintf </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>PetscScalar array to print to screen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of scalar array to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of variable to output default to 'x' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewer</td><td>format for viewer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a728ecf3fee73eeb301802d577abd31dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscErrorCode PSE::printVec </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>name</em>[] = <code>&quot;x&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print Vec from PETSc type variable to screen. </p>
<dl class="section return"><dt>Returns</dt><dd>ierr from PetscErrorCode of PetscPrintf </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Vec array to print to screen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of scalar array to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of variable to output default to 'x' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4364796301e74a3d38cbca8de4983dc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PSE::printVecASCII </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>name</em>[] = <code>&quot;printVecASCII.txt&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscViewerFormat&#160;</td>
          <td class="paramname"><em>format</em> = <code>PETSC_VIEWER_DEFAULT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>view Petsc Vec variable to ASCII file </p>
<ul>
<li>Helpful runtime option:</li>
</ul>
<p>-draw_pause &lt;pause&gt; : sets time (in seconds) that the program pauses after PetscDrawPause() has been called (0 is default, -1 implies until user input). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Petsc Vec 1xn vector to print to screen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>filename to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>format for viewer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adcd72375bfd6c3e459eec96fcc9fb25b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PSE::printVecView </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>name</em>[] = <code>&quot;x&#160;viewer&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscViewerFormat&#160;</td>
          <td class="paramname"><em>format</em> = <code>PETSC_VIEWER_DEFAULT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>view PetscVec variable to screen Open an X-window viewer. Note that we specify the same communicator for the viewer as we used for the distributed vector (PETSC_COMM_WORLD). </p>
<ul>
<li>Helpful runtime option:</li>
</ul>
<p>-draw_pause &lt;pause&gt; : sets time (in seconds) that the program pauses after PetscDrawPause() has been called (0 is default, -1 implies until user input). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>PetscScalar array to print to screen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of variable to output default to 'x' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>format for viewer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5be5daaa46471496c89223afe91a5a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::Read_input_file </td>
          <td>(</td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>buff</em>[] = <code>&quot;input_file.json&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read an input file written in json format. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to hold data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>filename of binary to read (output of python script </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28d16ac83d532b86b8963e79437bbd76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::Read_MatLab </td>
          <td>(</td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>buff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read input matrix and vectors input data from a matlab files (be sure this uses the PetscBinaryWrite() MatLab function) Reads and sets y, yVec, z, zVec, q, qp1, alpha, Deltay, and Deltaz quantities in the <a class="el" href="namespacePSE.html">PSE</a> class. </p>
<dl class="section return"><dt>Returns</dt><dd>ierr </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to hold data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>filename (without endings) of binary matlab files to read (output of matlab script using PetscSpecific binary write functions and fwrite) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a48fecf23dc69ac871eefb7efdedbae0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscErrorCode PSE::Read_MatLabMat </td>
          <td>(</td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>buff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read complex scalar matrix from a matlab file (be sure this uses the PetscBinaryWrite() MatLab function) </p>
<dl class="section return"><dt>Returns</dt><dd>ierr </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>complex scalar matrix to return after reading file (uninitialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>filename of binary matlab file to read (output of matlab script using PetscSpecific binary write functions) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae5b961f444d5cc8a19d2ea6c466c26cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscErrorCode PSE::Read_MatLabVec </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>buff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read complex scalar vector from a matlab file (be sure this uses the PetscBinaryWrite() MatLab function) </p>
<dl class="section return"><dt>Returns</dt><dd>ierr </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>complex scalar vector to return after reading file (uninitialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>filename of binary matlab file to read (output of matlab script using PetscSpecific binary write functions) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a784a766a2f191bcdb42518a4054350c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::Read_q </td>
          <td>(</td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>buff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read q from a tofile output from python. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to hold data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>filename of binary to read (output of python script) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa00269ce280ff26c0efe6bf05eafc6d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::Read_q </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>buff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read q from a tofile output from python. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">output</td><td>vector to return after reading file (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>int size of vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>filename of binary to read (output of python script) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a16b0ae4a9f35cb44644b0b9fb8ce7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::Read_q </td>
          <td>(</td>
          <td class="paramtype">PetscScalar&#160;</td>
          <td class="paramname"><em>output</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>buff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read y from a tofile output from python. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>vector to return after reading file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>int size of vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>filename of binary to read (output of python script) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adebd5af66cc444f85082dae836c24ee0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::Read_q </td>
          <td>(</td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>buff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read complex scalar from a tofile output from python. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>complex scalar to return after reading file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>filename of binary to read (output of python script) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab7d5b769d9c0425545e1701eaa181e2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_A_and_B_OSS_zi </td>
          <td>(</td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>zi</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set A and B matrix for Orr-Sommerfeld equations for zi plane Note that the wavelike ansatz is \(u=\hat{u}(y,z) \exp (i (-\omega t + \alpha x))\) </p>
<p class="formulaDsp">
\[ \begin{aligned} (-i \omega - \frac{1}{Re}(\partial_y^2 + \partial_z^2))\hat{u} + U&#39; \hat{v} &amp;= \alpha (-i \hat{P} - \frac{i}{Re}(\partial_y \hat{v} + \partial_z \hat{w}) - iU \hat{u})\\ (-i \omega - \frac{1}{Re}(\partial_y^2 + \partial_z^2))\hat{v} + \partial_y \hat{P} &amp;= \alpha (- \frac{1}{Re}(\alpha \hat{v}) - iU \hat{v})\\ (\alpha \hat{v}) &amp;= \alpha \cdot \hat{v}\\ (-i \omega - \frac{1}{Re}(\partial_y^2 + \partial_z^2))\hat{w} + \partial_z \hat{P} &amp;= \alpha (- \frac{1}{Re}(\alpha \hat{w}) - iU \hat{w})\\ (\alpha \hat{w}) &amp;= \alpha \cdot \hat{w}\\ \partial_y \hat{v} + \partial_z \hat{w} &amp;= \alpha (-i \hat{u})\\ \end{aligned}\]
</p>
<p> Where we have </p>
<p class="formulaDsp">
\[ \begin{aligned} \mathbf{z}_i= \begin{bmatrix} \hat{u}\\ \alpha \hat{v}\\ \hat{v}\\ \alpha \hat{w}\\ \hat{w}\\ \hat{P} \end{bmatrix}_{z=z(i)} \textrm{ and } &amp; \mathbf{q} = \begin{bmatrix} \mathbf{z}_1\\ \mathbf{z}_2\\ \vdots \\ \mathbf{z}_{nz - 1}\\ \mathbf{z}_{nz}\\ \end{bmatrix}\\ \end{aligned}\]
</p>
<p> To solve the spatial eigenvalue problem \(\mathbf{\mathcal{A}q} = \alpha \mathbf{\mathcal{B}q}\) </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to store values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zi</td><td>zi plane of matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa03a89105e706fa67f7cd042c76a1be6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_A_and_Ds </td>
          <td>(</td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set A and B matrix for <a class="el" href="namespacePSE.html">PSE</a> equations </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class containing all matrices, vectors, scalars, and problem size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>\( \alpha \) eigenvalue from previous iteration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeeb30fb64d89502daeceb49f296c48de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_A_and_Ds_nonlinear </td>
          <td>(</td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set A and D matrix linear terms for <a class="el" href="namespacePSE.html">PSE</a> equations for nonlinear terms </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to store values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8ef0799fa0695c45ee5d5d66f4da8289"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_A_and_Ds_zi </td>
          <td>(</td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>zi</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set A and B matrix linear terms for <a class="el" href="namespacePSE.html">PSE</a> equations for zi plane (also sets the permutation matrices to extract u from q, etc. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to store values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>eigenvalue from previous iteration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zi</td><td>zi plane of matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b2ed663ec0562dc6e5e1ac5f48e1428"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_b </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>qn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set b vector from B and q as b=B*q </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>B matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qn</td><td>qn vector to multiply </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>b Vec (already initialized) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80f94bbe2f2fcbcdafc37ed00360ad86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_BCs </td>
          <td>(</td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>nz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets Boundary Condition equations in Matrix A and vector b in Ax=b linear system for solving the <a class="el" href="namespacePSE.html">PSE</a> equations </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>A matrix (already initialized) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>b Vec (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ny</td><td>size of y array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nz</td><td>size of z array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa04e24f274b343e927d35d88c1c51804"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_BCs </td>
          <td>(</td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets Boundary Condition equations in Matrix A and Matrix B in A+ B*dqdx=0 linear system for solving the <a class="el" href="namespacePSE.html">PSE</a> equations </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data class for flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3d814d4df74ea2faf8d09fd55227c0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Crank_Nicolson_Advance </td>
          <td>(</td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set up Crank-Nicolson advancing matrices A x = b system by creating matrices and setting BCs </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to store values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>q at last marching step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>eigenvalue from previous step </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1243b4f1e9b24d23fdb837af6bedcc16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_D </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>y</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>order</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscBool &amp;&#160;</td>
          <td class="paramname"><em>periodic</em> = <code>PETSC_FALSE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscBool &amp;&#160;</td>
          <td class="paramname"><em>reduce_wall_order</em> = <code>PETSC_TRUE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscBool &amp;&#160;</td>
          <td class="paramname"><em>uniform</em> = <code>PETSC_TRUE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set D matrix operator for specified order and derivative </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>array of y values of channel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>length of y values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>matrix(n by n) dth derivative of order O(h^order) assuming uniform y spacing (uninitialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data class to have flags </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>order of accuracy desired (assuming even e.g. 2,4,6,...) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>dth derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">periodic</td><td>periodic boundary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reduce_wall_order</td><td>reduce the order of accuracy at the wall? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uniform</td><td>uniform mesh? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="addfaa7ccc0701dca9c473434a9a83778"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Euler_Advance </td>
          <td>(</td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set up Euler advancing matrices A x = b system by creating matrices and setting BCs </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to store values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>q at last marching step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>eigenvalue \( \alpha \) from the previous iteration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0dd2b21db657dd50257c0eca0621db3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::set_input_value </td>
          <td>(</td>
          <td class="paramtype">Json::Value &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>buff</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscInt &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>take Json data and save it to value if it exists </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Json file after reading </td></tr>
    <tr><td class="paramname">buff</td><td>matching key to check if it exits, if it does, set the value </td></tr>
    <tr><td class="paramname">v</td><td>value to set if key is matching </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4aa3487090c04d91a14cd606793f431f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::set_input_value </td>
          <td>(</td>
          <td class="paramtype">Json::Value &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>buff</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscReal &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>take Json data and save it to value if it exists </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Json file after reading </td></tr>
    <tr><td class="paramname">buff</td><td>matching key to check if it exits, if it does, set the value </td></tr>
    <tr><td class="paramname">v</td><td>value to set if key is matching </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0f625fe247533b74e528da7ea7e601c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::set_input_value </td>
          <td>(</td>
          <td class="paramtype">Json::Value &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>buff</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>take Json data and save it to value if it exists </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Json file after reading </td></tr>
    <tr><td class="paramname">buff</td><td>matching key to check if it exits, if it does, set the value </td></tr>
    <tr><td class="paramname">v</td><td>value to set if key is matching </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a711aa62ae6bd4437389d7d3583215722"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::set_input_value </td>
          <td>(</td>
          <td class="paramtype">Json::Value &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>buff</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscBool &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>take Json data and save it to value if it exists </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Json file after reading </td></tr>
    <tr><td class="paramname">buff</td><td>matching key to check if it exits, if it does, set the value </td></tr>
    <tr><td class="paramname">v</td><td>value to set if key is matching </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf5f51e6045ce513b3cd96c63df07e8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::set_input_value </td>
          <td>(</td>
          <td class="paramtype">Json::Value &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>buff</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>take Json data and save it to value if it exists </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Json file after reading </td></tr>
    <tr><td class="paramname">buff</td><td>matching key to check if it exits, if it does, set the value </td></tr>
    <tr><td class="paramname">v</td><td>value tos et if key is matching (string) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6d1706451068d94665d452c3d61b2f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::set_input_value </td>
          <td>(</td>
          <td class="paramtype">Json::Value &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>buff</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>take Json data and save it to value if it exists </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Json file after reading </td></tr>
    <tr><td class="paramname">buff</td><td>matching key to check if it exits, if it does, set the value </td></tr>
    <tr><td class="paramname">v</td><td>value tos et if key is matching (string) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aadb460f33e3b6822bce281047b3f92df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Mat </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar *const *&#160;</td>
          <td class="paramname"><em>Ain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InsertMode &amp;&#160;</td>
          <td class="paramname"><em>addv</em> = <code>ADD_VALUES</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a matrix from PetscScalar 2D matrix to PETSc Mat type in parallel </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Ain</td><td>Matrix set on all processors as 2D array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of nxn matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>Mat to SetValues and output in parallel (uninitialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addv</td><td>insert values or add values to matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a6a03d71013c1832acb354e08eb4fa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Mat </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscBool &amp;&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>PETSC_TRUE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InsertMode &amp;&#160;</td>
          <td class="paramname"><em>addv</em> = <code>ADD_VALUES</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a diagonal of a matrix from scalar </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">diag</td><td>scalar value to set as diagonal in matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of nxn matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Mat to SetValues and output in parallel (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>diagonal offset in matrix (k=0 is main diagonal, k&gt;0 is above main diagonal, k&lt;0 is below main diagonal) default is 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parallel</td><td>set the matrix using Istart and Iend </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addv</td><td>insert values or add values to matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40a665211c867a946e6c2c97fac8261f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Mat </td>
          <td>(</td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Mat to assemble (already initialized) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b30d081fb841dec74e4dae61b5e32bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Mat </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscBool &amp;&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>PETSC_TRUE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InsertMode &amp;&#160;</td>
          <td class="paramname"><em>addv</em> = <code>ADD_VALUES</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a single value in matrix at row,col </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>value to set in Mat A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>specified global row in Mat A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>specified global col in Mat A </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Matrix A to set value (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parallel</td><td>do this in parallel? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addv</td><td>insert values or add values to matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9459290168f207d9839bcde63e5a56a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Mat </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>Asub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>nsub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>rowoffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>coloffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InsertMode &amp;&#160;</td>
          <td class="paramname"><em>addv</em> = <code>ADD_VALUES</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a submatrix Asub in a matrix A </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>premultple to Asub </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Asub</td><td>sub matrix to set into mat </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nsub</td><td>nxn size of square sub matrix Asub </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Matrix A to set value (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of square Matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowoffset</td><td>start inserting Asub in A starting at rowoffset row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coloffset</td><td>start inserting Asub in A starting at coloffset column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addv</td><td>insert values or add values to matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac507f97367f3c93c65edf8f0131552bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Mat </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar *&#160;</td>
          <td class="paramname"><em>Ain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt&#160;</td>
          <td class="paramname"><em>cols</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InsertMode &amp;&#160;</td>
          <td class="paramname"><em>addv</em> = <code>ADD_VALUES</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a row of PetscScalar to a matrix to PETSc Mat </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Ain</td><td>array to set in row of matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>row to set in matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ncols</td><td>ncols of array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cols</td><td>cols to set in matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Mat to SetValues and output in parallel (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addv</td><td>insert values or add values to matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6dce2e6e9dbd48dd8e89f43ec4ac98d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Mat </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>Dz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>zi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>nvars</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>rowoffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>coloffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InsertMode &amp;&#160;</td>
          <td class="paramname"><em>addv</em> = <code>ADD_VALUES</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a Dz submatrix into A </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>premultple to Dz </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Dz</td><td>sub matrix to set into mat in z direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nz</td><td>nzxnz size of square sub matrix Dz </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ny</td><td>length of y array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zi</td><td>which z plane you are looking at </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Matrix A to set value (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of square Matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nvars</td><td>number of variables in vector 4 if (u,v,w,P) or 6 if (u, v, av, w, aw, P) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowoffset</td><td>start inserting Asub in A starting at rowoffset row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coloffset</td><td>start inserting Asub in A starting at coloffset column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addv</td><td>insert values or add values to matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaca217cde478d73b5469f46e51a48be9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Mat_broadcast_from_colVec </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a matrix from a column vector (broadcast the column vector to all columns of a matrix Be sure that A is already initialized </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>column Vec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>length of Vec </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>Matrix of size nxn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5fea93f0b43d3be5d423ab9259b42935"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Mat_efDz_into_A </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat *&#160;</td>
          <td class="paramname"><em>efDz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>yi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>zi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>nvars</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>rowoffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>coloffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InsertMode &amp;&#160;</td>
          <td class="paramname"><em>addv</em> = <code>ADD_VALUES</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set an array of Matrices efDz of array length ny and each Mat size of nz x nz into the large A matrix of size 4*ny*nz This must be called for each ny,nz point to set the efDz into the correct spots in A </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>premultple to efDz (usually set to one) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">efDz</td><td>sub matrix to set into mat in z direction (array of size ny each matrix of size nz,nz) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nz</td><td>nzxnz size of square sub matrix Dz </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yi</td><td>which y pt you are looking at </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zi</td><td>which z plane you are looking at </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Matrix A to set value (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of square Matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nvars</td><td>number of variables in vector 4 if (u,v,w,P) or 6 if (u, v, av, w, aw, P) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowoffset</td><td>start inserting Asub in A starting at rowoffset row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coloffset</td><td>start inserting Asub in A starting at coloffset column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addv</td><td>insert values or add values to matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a571185db1144849b1bf9f27e4dd9c3be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Mat_from_bf_Dy </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>bf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscInt &amp;&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscInt &amp;&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>Dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat *&#160;</td>
          <td class="paramname"><em>P_bfnyi_from_bfnynz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat *&#160;</td>
          <td class="paramname"><em>bfDy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set an array of Matrices bfDy of array length nz and each Mat size of ny x ny from a vector bf (ny*nz) MatMatMult multiplied by Dy Be sure that each array Mat of bfDy is already initialized, and bf and Dy are already created with values </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bf</td><td>vector of length ny*nz </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ny</td><td>ny, number of pts in y-direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nz</td><td>nz, number of pts in z-direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Dy</td><td>derivative operator of vector of length ny </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P_bfnyi_from_bfnynz</td><td>array of matrices to extract bf of length ny at z coordinate i from bf of length ny*nz </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bfDy</td><td>array of matrices to be set (each Mat of size ny,ny) and array length of nz </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7af3dc32aff4e33533b8595ad7ab555"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Mat_from_ef_Dz </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>ef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscInt &amp;&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscInt &amp;&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>Dz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat *&#160;</td>
          <td class="paramname"><em>P_efnzi_from_efnynz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat *&#160;</td>
          <td class="paramname"><em>efDz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set an array of Matrices efDz of array length ny and each Mat size of nz x nz from a vector ef (ny*nz) MatMatMult multiplied by Dz Be sure that each array Mat of efDz is already initialized, and ef and Dz are already created with values </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ef</td><td>vector of length ny*nz </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ny</td><td>ny, number of pts in y-direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nz</td><td>nz, number of pts in z-direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Dz</td><td>derivative operator of vector of length nz </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P_efnzi_from_efnynz</td><td>array of matrices to extract ef of length nz at y coordinate i from ef of length ny*nz </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">efDz</td><td>array of matrices to be set (each Mat of size nz,nz) and array length of ny </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa82823d0901aa0c7d667a8f02379cf50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Mat_from_Vec </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscInt &amp;&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscInt &amp;&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscInt &amp;&#160;</td>
          <td class="paramname"><em>rowoffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InsertMode &amp;&#160;</td>
          <td class="paramname"><em>addv</em> = <code>ADD_VALUES</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a matrix A (large ny*nz*4) from a vector (ny*nz) (used in the diagonals) at a certain rowoffset (between 0-ny*3). Be sure that A is already initialized </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>column Vec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ny</td><td>length of Vec is ny*nz </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nz</td><td>length of Vec is ny*nz </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowoffset</td><td>start inserting Vec in A starting at rowoffset row </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Matrix of size ny*nz*4 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addv</td><td>insert values or add values to matrix A (default ADD_VALUES) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f2df7541e3595870bb4782d962de131"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_MatDiagonalScale </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>diag_to_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>Asub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>nsub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>rowoffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>coloffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InsertMode &amp;&#160;</td>
          <td class="paramname"><em>addv</em> = <code>ADD_VALUES</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a scaled matrix, (rows are scaled by matrix, using A=LA and MatDiagonalScale) </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">diag_to_scale</td><td>premultple to scale the rows of Asub </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Asub</td><td>sub matrix to set into mat </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nsub</td><td>nxn size of square sub matrix Asub </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Matrix A to set value (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of square Matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowoffset</td><td>start inserting Asub in A starting at rowoffset row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coloffset</td><td>start inserting Asub in A starting at coloffset column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addv</td><td>insert values or add values to matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6401d0b66259dc17e248b11ba8994c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Vec </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar *&#160;</td>
          <td class="paramname"><em>bin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscBool &amp;&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>PETSC_TRUE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a vector from PetscScalar 1D vector to PETSc Vec type in parallel </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bin</td><td>array set on all processors as 1D array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of n array </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>Vec to SetValues and output in parallel (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parallel</td><td>set in parallel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a21cf4be41ee60bc04f43dca61f15e0bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Vec </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble b vector. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>array to assemble on all processors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67d517f522b7038fb21aded9c8113d49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Vec </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>bin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a vector from PetscScalar to PETSc Vec in location n </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bin</td><td>scalar to set into Vec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>location to put into Vec </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>Vec to SetValues (already initialized) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aadbaa2fa2002e60d96e1019140975e98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt PSE::set_Vec </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>inVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a subvector from larger vector from low to hi indices </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inVec</td><td>larger vec to copy values from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">low</td><td>lower bound </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hi</td><td>upper bound </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>Vec to SetValues and output (already initialized) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a830c6be6ce992c9db886bc9afa8321d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::trapz </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>trapezoidal rule on Vec with ny,nz values </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>Vector to integrate </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>value of integration </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>data class to store Trapzy and Trapzz value and flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a00d6a319bd35d2b3b49f35b53b06db28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::update_Closure </td>
          <td>(</td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>qp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code>50</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the closure equation \( \int_\Omega \hat{\textbf{q}}^\dagger \hat{\textbf{q}}_x dy \) and output the result This is part of the solution procedure shown in the bottom half of this diagram  <style>div.image img[src="SolutionProcedure.png"]{width:8.5in;}</style>  </p>
<div class="image">
<img src="SolutionProcedure.png" alt="SolutionProcedure.png"/>
<div class="caption">
Solution Procedure</div></div>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to store values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>q at previous marching step </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">qp1</td><td>current marching step </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">alpha</td><td>\( \alpha \) value at current marching step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxiter</td><td>maximum number of iterations (not implimented) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a18f68cc4e295b911e3dedd896a9d7ca5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PSE::update_Nonlinear </td>
          <td>(</td>
          <td class="paramtype">PSE &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>qp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>alpha_old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>Ialpha_old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>Ialpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code>50</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>advance the Nonlinear <a class="el" href="namespacePSE.html">PSE</a> system one x step </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to store values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>q at previous marching step </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">qp1</td><td>current marching step </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">alpha_old</td><td>\( \alpha \) value at previous marching step (will be updated) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">alpha</td><td>\( \alpha \) value at current marching step </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Ialpha_old</td><td>\( \int_{x_0}^{x_{i+1}} \alpha dx \) value at previous marching step </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Ialpha</td><td>\( \int_{x_0}^{x_{i+1}} \alpha dx \) value at current marching step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxiter</td><td>maximum number of iterations (not implimented) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
