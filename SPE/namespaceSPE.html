<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>SPE Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="spe2_black_smaller.png"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SPE Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace containing all functions and data classes for this solver.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSPE_1_1Mat__4terms.html">Mat_4terms</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure for 4 mats to have u_term, v_term, w_term, P_term Mat  <a href="structSPE_1_1Mat__4terms.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPE_1_1SPE.html">SPE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to contain various variables for <a class="el" href="classSPE_1_1SPE.html" title="Class to contain various variables for SPE solution. ">SPE</a> solution.  <a href="classSPE_1_1SPE.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a987d1c140c3de2c40e5fc4569f6f85d1"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a987d1c140c3de2c40e5fc4569f6f85d1">Ax_b</a> (const PetscScalar *const *Ain, Vec &amp;x, const PetscScalar bin[], const PetscInt &amp;n)</td></tr>
<tr class="memdesc:a987d1c140c3de2c40e5fc4569f6f85d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves \(x\) in \(Ax=b\) linalg problem using PETSc in parallel Useful for solving small systems of equations, such as finite difference coefficients for given stencils.  <a href="#a987d1c140c3de2c40e5fc4569f6f85d1">More...</a><br /></td></tr>
<tr class="separator:a987d1c140c3de2c40e5fc4569f6f85d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc6a97a8a7ebfb8f40f1862ec2c71ef"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a9bc6a97a8a7ebfb8f40f1862ec2c71ef">Ax_b</a> (const Mat &amp;A, Vec &amp;x, const Vec &amp;b, const PetscInt &amp;n)</td></tr>
<tr class="memdesc:a9bc6a97a8a7ebfb8f40f1862ec2c71ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves \(x\) in \(Ax=b\) linalg problem using PETSc in parallel.  <a href="#a9bc6a97a8a7ebfb8f40f1862ec2c71ef">More...</a><br /></td></tr>
<tr class="separator:a9bc6a97a8a7ebfb8f40f1862ec2c71ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f26ce4b77bbab2090739d54da585bc3"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a6f26ce4b77bbab2090739d54da585bc3">Ax_kBx</a> (const Mat &amp;A, const Mat &amp;B, PetscScalar &amp;kr, PetscScalar &amp;ki, Vec &amp;xr, Vec &amp;xi, PetscScalar target=0.54213+0.082968 *PETSC_i, PetscInt nev=1, EPSWhich which=EPS_TARGET_MAGNITUDE)</td></tr>
<tr class="memdesc:a6f26ce4b77bbab2090739d54da585bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves \(x\) in \(Ax=kBx\) eigenvalue problem using SLEPc in parallel.  <a href="#a6f26ce4b77bbab2090739d54da585bc3">More...</a><br /></td></tr>
<tr class="separator:a6f26ce4b77bbab2090739d54da585bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a86a4b0bc0a7380655c721d2f7e3b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a66a86a4b0bc0a7380655c721d2f7e3b0">base_flow</a> (<a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data)</td></tr>
<tr class="memdesc:a66a86a4b0bc0a7380655c721d2f7e3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">set plane channel or blasius boundary layer flow velocity variables \(U, U_x, U_y,\) and etc Note: type_base_flow has an integer flag that corresponds with the following flow types  <a href="#a66a86a4b0bc0a7380655c721d2f7e3b0">More...</a><br /></td></tr>
<tr class="separator:a66a86a4b0bc0a7380655c721d2f7e3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015c604f670fd5aa93f19971b0b46d40"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a015c604f670fd5aa93f19971b0b46d40">_bblf</a> (const PetscScalar input[3], PetscScalar output[3])</td></tr>
<tr class="memdesc:a015c604f670fd5aa93f19971b0b46d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blasius boundary layer function to integrate. Similarity Blasius ODE broken into three coupled equations </p><p class="formulaDsp">
\[ \begin{aligned} f&#39;&#39; &amp;= \int -ff&#39;&#39; d\eta\\ f&#39; &amp;= \int f&#39;&#39; d\eta\\ f &amp;= \int f&#39; d\eta\\ \end{aligned} \]
</p>
<p>.  <a href="#a015c604f670fd5aa93f19971b0b46d40">More...</a><br /></td></tr>
<tr class="separator:a015c604f670fd5aa93f19971b0b46d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c3f1eb587408213001e6a5ed8c82ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a73c3f1eb587408213001e6a5ed8c82ce">base_flow_dim</a> (<a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data)</td></tr>
<tr class="memdesc:a73c3f1eb587408213001e6a5ed8c82ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this after base_flow(data) call to set the ny matrices to size dim. So U is set into U_dim.  <a href="#a73c3f1eb587408213001e6a5ed8c82ce">More...</a><br /></td></tr>
<tr class="separator:a73c3f1eb587408213001e6a5ed8c82ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b473e31d0e9421cdc887c11e0baf792"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a8b473e31d0e9421cdc887c11e0baf792">calc_Closure</a> (PetscScalar &amp;I, <a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data, Vec &amp;q, Vec &amp;qp1)</td></tr>
<tr class="memdesc:a8b473e31d0e9421cdc887c11e0baf792"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the closure equation \( \int_{\Omega} \hat{\textbf{q}}^\dagger \hat{\textbf{q}}_x d\Omega \) and output the result  <a href="#a8b473e31d0e9421cdc887c11e0baf792">More...</a><br /></td></tr>
<tr class="separator:a8b473e31d0e9421cdc887c11e0baf792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116be7eaa0729c0d593458e88f0daff9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a116be7eaa0729c0d593458e88f0daff9">calc_L2</a> (PetscReal &amp;error, Vec &amp;x1, Vec &amp;x2, PetscInt n, NormType type=NORM_2)</td></tr>
<tr class="memdesc:a116be7eaa0729c0d593458e88f0daff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the \( L_2 \) norm of the difference between \(x_1\) and \(x_2\) vectors and return  <a href="#a116be7eaa0729c0d593458e88f0daff9">More...</a><br /></td></tr>
<tr class="separator:a116be7eaa0729c0d593458e88f0daff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab462173f3b98c1b085f7411036ac7b4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#ab462173f3b98c1b085f7411036ac7b4a">calc_L2</a> (PetscReal &amp;error, Mat &amp;x1, Mat &amp;x2, PetscInt n, NormType type=NORM_2)</td></tr>
<tr class="memdesc:ab462173f3b98c1b085f7411036ac7b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the \( L_2 \) norm of the difference between \(x_1\) and \(x_2\) matrix diagonals and return  <a href="#ab462173f3b98c1b085f7411036ac7b4a">More...</a><br /></td></tr>
<tr class="separator:ab462173f3b98c1b085f7411036ac7b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4baf182ac98c709701d2ac22268516a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a4baf182ac98c709701d2ac22268516a2">calc_LST</a> (<a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data, PetscScalar target_alpha, PetscScalar &amp;alpha, Vec &amp;qp1_OSS, Vec &amp;qp1)</td></tr>
<tr class="memdesc:a4baf182ac98c709701d2ac22268516a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the Local Stability Theory (LST) Orr-Sommerfeld Squire equations in primitive variables at this x-location and store the alpha and qp1 of the target spatial values.  <a href="#a4baf182ac98c709701d2ac22268516a2">More...</a><br /></td></tr>
<tr class="separator:a4baf182ac98c709701d2ac22268516a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6146385b9d4b24a455bb34a37c602ac2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a6146385b9d4b24a455bb34a37c602ac2">Create_grid</a> (<a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data, PetscScalar deltay=0.)</td></tr>
<tr class="memdesc:a6146385b9d4b24a455bb34a37c602ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">create y and z grid and stretch in y direction using stretching if deltay is nonzero  <a href="#a6146385b9d4b24a455bb34a37c602ac2">More...</a><br /></td></tr>
<tr class="separator:a6146385b9d4b24a455bb34a37c602ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee145e1de6014859604b6470f908a5da"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#aee145e1de6014859604b6470f908a5da">factorial</a> (unsigned n)</td></tr>
<tr class="memdesc:aee145e1de6014859604b6470f908a5da"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the factorial of an integer  <a href="#aee145e1de6014859604b6470f908a5da">More...</a><br /></td></tr>
<tr class="separator:aee145e1de6014859604b6470f908a5da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83096d834607fbcff7dea5c1b2be52f"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#ac83096d834607fbcff7dea5c1b2be52f">get_D_Coeffs</a> (const PetscScalar s[], const PetscInt &amp;n, Vec &amp;output, const PetscInt &amp;d=2)</td></tr>
<tr class="memdesc:ac83096d834607fbcff7dea5c1b2be52f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve arbitrary stencil points s of length N with order of derivatives d&lt;N can be obtained from equation on MIT website <a href="http://web.media.mit.edu/~crtaylor/calculator.html">http://web.media.mit.edu/~crtaylor/calculator.html</a> where the accuracy is determined as the usual form O(h^(N-d))  <a href="#ac83096d834607fbcff7dea5c1b2be52f">More...</a><br /></td></tr>
<tr class="separator:ac83096d834607fbcff7dea5c1b2be52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba10b99628bf94467786d42692daed8a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#aba10b99628bf94467786d42692daed8a">Init_Mat</a> (Mat &amp;A, const PetscInt &amp;n)</td></tr>
<tr class="memdesc:aba10b99628bf94467786d42692daed8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a Matrix A to be of size nxn.  <a href="#aba10b99628bf94467786d42692daed8a">More...</a><br /></td></tr>
<tr class="separator:aba10b99628bf94467786d42692daed8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb71547055ae4dd811cfc9478b0dbbc9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#afb71547055ae4dd811cfc9478b0dbbc9">Init_Mat</a> (Mat &amp;A, const PetscInt &amp;m, const PetscInt &amp;n)</td></tr>
<tr class="memdesc:afb71547055ae4dd811cfc9478b0dbbc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a Matrix A to be of size mxn.  <a href="#afb71547055ae4dd811cfc9478b0dbbc9">More...</a><br /></td></tr>
<tr class="separator:afb71547055ae4dd811cfc9478b0dbbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856eb47a60d74969a9894326c2ad9bb7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a856eb47a60d74969a9894326c2ad9bb7">Init_Vec</a> (Vec &amp;x, const PetscInt &amp;n)</td></tr>
<tr class="memdesc:a856eb47a60d74969a9894326c2ad9bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a vector x to be of size n.  <a href="#a856eb47a60d74969a9894326c2ad9bb7">More...</a><br /></td></tr>
<tr class="separator:a856eb47a60d74969a9894326c2ad9bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28f22e36aaf616f05cfd6618a0411c5"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#ad28f22e36aaf616f05cfd6618a0411c5">map_D</a> (Mat &amp;output, <a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data, const PetscInt &amp;n, Vec &amp;yVec, const PetscInt &amp;order=2, const PetscInt &amp;d=2, const PetscBool &amp;periodic=PETSC_FALSE, const PetscBool &amp;staggered=PETSC_FALSE, const PetscBool &amp;reduce_wall_order=PETSC_TRUE)</td></tr>
<tr class="memdesc:ad28f22e36aaf616f05cfd6618a0411c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">map D matrix operator for specified order and derivative, for a non-uniform mesh  <a href="#ad28f22e36aaf616f05cfd6618a0411c5">More...</a><br /></td></tr>
<tr class="separator:ad28f22e36aaf616f05cfd6618a0411c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45ff39ed31723e63ae72bf2b2f5fd73"><td class="memItemLeft" align="right" valign="top">PetscErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#ab45ff39ed31723e63ae72bf2b2f5fd73">printScalar</a> (const PetscScalar x[], const PetscInt n=1, char const name[]=&quot;x&quot;, const PetscViewer viewer=PETSC_VIEWER_STDOUT_WORLD)</td></tr>
<tr class="memdesc:ab45ff39ed31723e63ae72bf2b2f5fd73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print PetscScalar variable to screen.  <a href="#ab45ff39ed31723e63ae72bf2b2f5fd73">More...</a><br /></td></tr>
<tr class="separator:ab45ff39ed31723e63ae72bf2b2f5fd73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab440e97505010fd1d1448a2f5efc8c60"><td class="memItemLeft" align="right" valign="top">PetscErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#ab440e97505010fd1d1448a2f5efc8c60">printReal</a> (const PetscReal x[], const PetscInt n=1, char const name[]=&quot;x&quot;, const PetscViewer viewer=PETSC_VIEWER_STDOUT_WORLD)</td></tr>
<tr class="memdesc:ab440e97505010fd1d1448a2f5efc8c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print PetscReal variable to screen.  <a href="#ab440e97505010fd1d1448a2f5efc8c60">More...</a><br /></td></tr>
<tr class="separator:ab440e97505010fd1d1448a2f5efc8c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b7e7d6563ccede850e1f0bf63a674d"><td class="memItemLeft" align="right" valign="top">PetscErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a70b7e7d6563ccede850e1f0bf63a674d">printVec</a> (const Vec &amp;x, const PetscInt n, char const name[]=&quot;x&quot;)</td></tr>
<tr class="memdesc:a70b7e7d6563ccede850e1f0bf63a674d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print Vec from PETSc type variable to screen.  <a href="#a70b7e7d6563ccede850e1f0bf63a674d">More...</a><br /></td></tr>
<tr class="separator:a70b7e7d6563ccede850e1f0bf63a674d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6db8781df123af6a423aafd4de8dbd"><td class="memItemLeft" align="right" valign="top">PetscErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#ade6db8781df123af6a423aafd4de8dbd">printInt</a> (const PetscInt x[], const PetscInt n=1, char const name[]=&quot;x&quot;)</td></tr>
<tr class="memdesc:ade6db8781df123af6a423aafd4de8dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print PetscInt variable to screen.  <a href="#ade6db8781df123af6a423aafd4de8dbd">More...</a><br /></td></tr>
<tr class="separator:ade6db8781df123af6a423aafd4de8dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab542316e02bd55571faece4af34d5ed2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#ab542316e02bd55571faece4af34d5ed2">printVecView</a> (const Vec &amp;x, char const name[]=&quot;x viewer&quot;, const PetscViewerFormat format=PETSC_VIEWER_DEFAULT)</td></tr>
<tr class="memdesc:ab542316e02bd55571faece4af34d5ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">view PetscVec variable to screen Open an X-window viewer. Note that we specify the same communicator for the viewer as we used for the distributed vector (PETSC_COMM_WORLD).  <a href="#ab542316e02bd55571faece4af34d5ed2">More...</a><br /></td></tr>
<tr class="separator:ab542316e02bd55571faece4af34d5ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4609deb337d7f056df3a3933e4e3fb6d"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a4609deb337d7f056df3a3933e4e3fb6d">printMatView</a> (const Mat &amp;A, char const name[]=&quot;A viewer&quot;, const PetscViewerFormat format=PETSC_VIEWER_DEFAULT)</td></tr>
<tr class="memdesc:a4609deb337d7f056df3a3933e4e3fb6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">view Petsc Mat variable to screen Open an X-window viewer. Note that we specify the same communicator for the viewer as we used for the distributed vector (PETSC_COMM_WORLD).  <a href="#a4609deb337d7f056df3a3933e4e3fb6d">More...</a><br /></td></tr>
<tr class="separator:a4609deb337d7f056df3a3933e4e3fb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e454a2558010d2c245324c4307384e"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#ad1e454a2558010d2c245324c4307384e">printMatASCII</a> (const Mat &amp;A, char const name[]=&quot;printMatASCII.txt&quot;, const PetscViewerFormat format=PETSC_VIEWER_DEFAULT)</td></tr>
<tr class="memdesc:ad1e454a2558010d2c245324c4307384e"><td class="mdescLeft">&#160;</td><td class="mdescRight">view Petsc Mat variable to ASCII file  <a href="#ad1e454a2558010d2c245324c4307384e">More...</a><br /></td></tr>
<tr class="separator:ad1e454a2558010d2c245324c4307384e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985ae79ebcb0a4ac6a998e412df88955"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a985ae79ebcb0a4ac6a998e412df88955">printMatASCII</a> (const Mat &amp;A, std::string name, const PetscViewerFormat format=PETSC_VIEWER_DEFAULT)</td></tr>
<tr class="memdesc:a985ae79ebcb0a4ac6a998e412df88955"><td class="mdescLeft">&#160;</td><td class="mdescRight">view Petsc Mat variable to ASCII file  <a href="#a985ae79ebcb0a4ac6a998e412df88955">More...</a><br /></td></tr>
<tr class="separator:a985ae79ebcb0a4ac6a998e412df88955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdd4cf955d3b3d1fa6e592cd2389efc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#affdd4cf955d3b3d1fa6e592cd2389efc">printMatGetDiagonalASCII</a> (const Mat &amp;A, char const name[]=&quot;printMatGetDiagonalASCII.txt&quot;, const PetscViewerFormat format=PETSC_VIEWER_ASCII_MATLAB)</td></tr>
<tr class="memdesc:affdd4cf955d3b3d1fa6e592cd2389efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">print diagonal of Petsc Mat variable to ASCII file  <a href="#affdd4cf955d3b3d1fa6e592cd2389efc">More...</a><br /></td></tr>
<tr class="separator:affdd4cf955d3b3d1fa6e592cd2389efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b95845145ea996b125784e1488733bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a8b95845145ea996b125784e1488733bd">printVecASCII</a> (const Vec &amp;b, char const name[]=&quot;printVecASCII.txt&quot;, const PetscViewerFormat format=PETSC_VIEWER_ASCII_MATLAB)</td></tr>
<tr class="memdesc:a8b95845145ea996b125784e1488733bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">view Petsc Vec variable to ASCII file  <a href="#a8b95845145ea996b125784e1488733bd">More...</a><br /></td></tr>
<tr class="separator:a8b95845145ea996b125784e1488733bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303746d7ec502ae5fd001d4fd1e9dcc2"><td class="memItemLeft" align="right" valign="top">PetscErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a303746d7ec502ae5fd001d4fd1e9dcc2">printClosureIter</a> (<a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data)</td></tr>
<tr class="memdesc:a303746d7ec502ae5fd001d4fd1e9dcc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">print iteration residuals to screen from update_Closure iterations  <a href="#a303746d7ec502ae5fd001d4fd1e9dcc2">More...</a><br /></td></tr>
<tr class="separator:a303746d7ec502ae5fd001d4fd1e9dcc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0115f2a12d942e4fa08ab8e2f01b975"><td class="memItemLeft" align="right" valign="top">PetscErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#ad0115f2a12d942e4fa08ab8e2f01b975">printNonlinearIter</a> (<a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data)</td></tr>
<tr class="memdesc:ad0115f2a12d942e4fa08ab8e2f01b975"><td class="mdescLeft">&#160;</td><td class="mdescRight">print iteration residuals to screen from update_Nonlinear iterations  <a href="#ad0115f2a12d942e4fa08ab8e2f01b975">More...</a><br /></td></tr>
<tr class="separator:ad0115f2a12d942e4fa08ab8e2f01b975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cef2622446eec7da75349151b7a7892"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a4cef2622446eec7da75349151b7a7892">printHeaderIter</a> ()</td></tr>
<tr class="memdesc:a4cef2622446eec7da75349151b7a7892"><td class="mdescLeft">&#160;</td><td class="mdescRight">print iteration residuals header to screen  <a href="#a4cef2622446eec7da75349151b7a7892">More...</a><br /></td></tr>
<tr class="separator:a4cef2622446eec7da75349151b7a7892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11073a2d25024515f3df17fbf68318f6"><td class="memItemLeft" align="right" valign="top">PetscErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a11073a2d25024515f3df17fbf68318f6">printBaseNonlinearIter</a> (<a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data, PetscReal basenonlinear_error, PetscInt basenonlinear_iter)</td></tr>
<tr class="memdesc:a11073a2d25024515f3df17fbf68318f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">print iteration residuals to screen from baseflow nonlinear iterations  <a href="#a11073a2d25024515f3df17fbf68318f6">More...</a><br /></td></tr>
<tr class="separator:a11073a2d25024515f3df17fbf68318f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58acf300ce545c131aa45a572e57ad35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a58acf300ce545c131aa45a572e57ad35">Read_input_file</a> (<a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data, char const buff[]=&quot;input_file.json&quot;)</td></tr>
<tr class="memdesc:a58acf300ce545c131aa45a572e57ad35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an input file written in json format.  <a href="#a58acf300ce545c131aa45a572e57ad35">More...</a><br /></td></tr>
<tr class="separator:a58acf300ce545c131aa45a572e57ad35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81919c87d8b6ffe6da239599c3d2cf2b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a81919c87d8b6ffe6da239599c3d2cf2b">set_input_value</a> (<a class="el" href="classJson_1_1Value.html">Json::Value</a> &amp;val, const char buff[], PetscInt &amp;v)</td></tr>
<tr class="memdesc:a81919c87d8b6ffe6da239599c3d2cf2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">take <a class="el" href="namespaceJson.html" title="JSON (JavaScript Object Notation). ">Json</a> data and save it to value if it exists  <a href="#a81919c87d8b6ffe6da239599c3d2cf2b">More...</a><br /></td></tr>
<tr class="separator:a81919c87d8b6ffe6da239599c3d2cf2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9c276163bcef0fcff79ced71838741"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#afb9c276163bcef0fcff79ced71838741">set_input_value</a> (<a class="el" href="classJson_1_1Value.html">Json::Value</a> &amp;val, const char buff[], PetscReal &amp;v)</td></tr>
<tr class="memdesc:afb9c276163bcef0fcff79ced71838741"><td class="mdescLeft">&#160;</td><td class="mdescRight">take <a class="el" href="namespaceJson.html" title="JSON (JavaScript Object Notation). ">Json</a> data and save it to value if it exists  <a href="#afb9c276163bcef0fcff79ced71838741">More...</a><br /></td></tr>
<tr class="separator:afb9c276163bcef0fcff79ced71838741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee53c952e93397330ab021f836246e5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#aee53c952e93397330ab021f836246e5e">set_input_value</a> (<a class="el" href="classJson_1_1Value.html">Json::Value</a> &amp;val, const char buff[], PetscScalar &amp;v)</td></tr>
<tr class="memdesc:aee53c952e93397330ab021f836246e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">take <a class="el" href="namespaceJson.html" title="JSON (JavaScript Object Notation). ">Json</a> data and save it to value if it exists  <a href="#aee53c952e93397330ab021f836246e5e">More...</a><br /></td></tr>
<tr class="separator:aee53c952e93397330ab021f836246e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5166674d41c473ffd01fa89e68675630"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a5166674d41c473ffd01fa89e68675630">set_input_value</a> (<a class="el" href="classJson_1_1Value.html">Json::Value</a> &amp;val, const char buff[], PetscBool &amp;v)</td></tr>
<tr class="memdesc:a5166674d41c473ffd01fa89e68675630"><td class="mdescLeft">&#160;</td><td class="mdescRight">take <a class="el" href="namespaceJson.html" title="JSON (JavaScript Object Notation). ">Json</a> data and save it to value if it exists  <a href="#a5166674d41c473ffd01fa89e68675630">More...</a><br /></td></tr>
<tr class="separator:a5166674d41c473ffd01fa89e68675630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c5f0b0fb66915b97905763bf9406e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a09c5f0b0fb66915b97905763bf9406e3">set_input_value</a> (<a class="el" href="classJson_1_1Value.html">Json::Value</a> &amp;val, const char buff[], char *v)</td></tr>
<tr class="memdesc:a09c5f0b0fb66915b97905763bf9406e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">take <a class="el" href="namespaceJson.html" title="JSON (JavaScript Object Notation). ">Json</a> data and save it to value if it exists  <a href="#a09c5f0b0fb66915b97905763bf9406e3">More...</a><br /></td></tr>
<tr class="separator:a09c5f0b0fb66915b97905763bf9406e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71d6dbe78287c061e726471ba643923"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#ad71d6dbe78287c061e726471ba643923">set_input_value</a> (<a class="el" href="classJson_1_1Value.html">Json::Value</a> &amp;val, const char buff[], std::string &amp;v)</td></tr>
<tr class="memdesc:ad71d6dbe78287c061e726471ba643923"><td class="mdescLeft">&#160;</td><td class="mdescRight">take <a class="el" href="namespaceJson.html" title="JSON (JavaScript Object Notation). ">Json</a> data and save it to value if it exists  <a href="#ad71d6dbe78287c061e726471ba643923">More...</a><br /></td></tr>
<tr class="separator:ad71d6dbe78287c061e726471ba643923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af148ab7e7fc4ec635bdc8a028fd0ef6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#af148ab7e7fc4ec635bdc8a028fd0ef6a">Read_q</a> (<a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data, std::string &amp;buff)</td></tr>
<tr class="memdesc:af148ab7e7fc4ec635bdc8a028fd0ef6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read q from a tofile output from python.  <a href="#af148ab7e7fc4ec635bdc8a028fd0ef6a">More...</a><br /></td></tr>
<tr class="separator:af148ab7e7fc4ec635bdc8a028fd0ef6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8fbf8253402387e0615ec07e12aa02"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a3e8fbf8253402387e0615ec07e12aa02">Read_q</a> (Vec &amp;output, const int n, std::string &amp;buff)</td></tr>
<tr class="memdesc:a3e8fbf8253402387e0615ec07e12aa02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read q from a tofile output from python.  <a href="#a3e8fbf8253402387e0615ec07e12aa02">More...</a><br /></td></tr>
<tr class="separator:a3e8fbf8253402387e0615ec07e12aa02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3921882dcf3896f32283eb812f99bee5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a3921882dcf3896f32283eb812f99bee5">Read_q</a> (PetscScalar output[], const int n, std::string &amp;buff)</td></tr>
<tr class="memdesc:a3921882dcf3896f32283eb812f99bee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read y from a tofile output from python.  <a href="#a3921882dcf3896f32283eb812f99bee5">More...</a><br /></td></tr>
<tr class="separator:a3921882dcf3896f32283eb812f99bee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93ece36a6dba0035fad72abb73080e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#ad93ece36a6dba0035fad72abb73080e4">Read_q</a> (PetscScalar &amp;output, std::string &amp;buff)</td></tr>
<tr class="memdesc:ad93ece36a6dba0035fad72abb73080e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read complex scalar from a tofile output from python.  <a href="#ad93ece36a6dba0035fad72abb73080e4">More...</a><br /></td></tr>
<tr class="separator:ad93ece36a6dba0035fad72abb73080e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86cff5c8b04a8713b4bb180c6c1bc84"><td class="memItemLeft" align="right" valign="top">PetscErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#ad86cff5c8b04a8713b4bb180c6c1bc84">Read_MatLabVec</a> (Vec &amp;output, std::string &amp;buff)</td></tr>
<tr class="memdesc:ad86cff5c8b04a8713b4bb180c6c1bc84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read complex scalar vector from a matlab file (be sure this uses the PetscBinaryWrite() MatLab function)  <a href="#ad86cff5c8b04a8713b4bb180c6c1bc84">More...</a><br /></td></tr>
<tr class="separator:ad86cff5c8b04a8713b4bb180c6c1bc84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27420a6628d48ef5879fb5074428401b"><td class="memItemLeft" align="right" valign="top">PetscErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a27420a6628d48ef5879fb5074428401b">Read_MatLabMat</a> (Mat &amp;output, std::string &amp;buff)</td></tr>
<tr class="memdesc:a27420a6628d48ef5879fb5074428401b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read complex scalar matrix from a matlab file (be sure this uses the PetscBinaryWrite() MatLab function)  <a href="#a27420a6628d48ef5879fb5074428401b">More...</a><br /></td></tr>
<tr class="separator:a27420a6628d48ef5879fb5074428401b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dfc5d5b35399aa4402d1eb5e677f176"><td class="memItemLeft" align="right" valign="top">PetscErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a6dfc5d5b35399aa4402d1eb5e677f176">Read_MatLab</a> (<a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data, std::string &amp;buff)</td></tr>
<tr class="memdesc:a6dfc5d5b35399aa4402d1eb5e677f176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read input matrix and vectors input data from a matlab files (be sure this uses the PetscBinaryWrite() MatLab function) Reads and sets y, yVec, z, zVec, q, qp1, alpha, Deltay, and Deltaz quantities in the <a class="el" href="namespaceSPE.html" title="Namespace containing all functions and data classes for this solver. ">SPE</a> class.  <a href="#a6dfc5d5b35399aa4402d1eb5e677f176">More...</a><br /></td></tr>
<tr class="separator:a6dfc5d5b35399aa4402d1eb5e677f176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07dee0f41e4f927ab226733077b8164"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#aa07dee0f41e4f927ab226733077b8164">set_A_and_B_OSS_zi</a> (<a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data, const PetscInt &amp;zi=0)</td></tr>
<tr class="memdesc:aa07dee0f41e4f927ab226733077b8164"><td class="mdescLeft">&#160;</td><td class="mdescRight">set A and B matrix for Orr-Sommerfeld equations for zi plane Note that the wavelike ansatz is \(u=\hat{u}(y,z) \exp (i (-\omega t + \alpha x))\) </p><p class="formulaDsp">
\[ \begin{aligned} (-i \omega - \frac{1}{Re}(\partial_y^2 + \partial_z^2))\hat{u} + U&#39; \hat{v} &amp;= \alpha (-i \hat{P} - \frac{i}{Re}(\partial_y \hat{v} + \partial_z \hat{w}) - iU \hat{u})\\ (-i \omega - \frac{1}{Re}(\partial_y^2 + \partial_z^2))\hat{v} + \partial_y \hat{P} &amp;= \alpha (- \frac{1}{Re}(\alpha \hat{v}) - iU \hat{v})\\ (\alpha \hat{v}) &amp;= \alpha \cdot \hat{v}\\ (-i \omega - \frac{1}{Re}(\partial_y^2 + \partial_z^2))\hat{w} + \partial_z \hat{P} &amp;= \alpha (- \frac{1}{Re}(\alpha \hat{w}) - iU \hat{w})\\ (\alpha \hat{w}) &amp;= \alpha \cdot \hat{w}\\ \partial_y \hat{v} + \partial_z \hat{w} &amp;= \alpha (-i \hat{u})\\ \end{aligned}\]
</p>
<p> Where we have </p><p class="formulaDsp">
\[ \begin{aligned} \mathbf{z}_i= \begin{bmatrix} \hat{u}\\ \alpha \hat{v}\\ \hat{v}\\ \alpha \hat{w}\\ \hat{w}\\ \hat{P} \end{bmatrix}_{z=z(i)} \textrm{ and } &amp; \mathbf{q} = \begin{bmatrix} \mathbf{z}_1\\ \mathbf{z}_2\\ \vdots \\ \mathbf{z}_{nz - 1}\\ \mathbf{z}_{nz}\\ \end{bmatrix}\\ \end{aligned}\]
</p>
<p> To solve the spatial eigenvalue problem \(\mathbf{\mathcal{A}q} = \alpha \mathbf{\mathcal{B}q}\)  <a href="#aa07dee0f41e4f927ab226733077b8164">More...</a><br /></td></tr>
<tr class="separator:aa07dee0f41e4f927ab226733077b8164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2905bf10e13fd461321cc46631ed7f"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a4b2905bf10e13fd461321cc46631ed7f">set_A_and_Ds</a> (<a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data, PetscScalar &amp;alpha)</td></tr>
<tr class="memdesc:a4b2905bf10e13fd461321cc46631ed7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">set A and B matrix for <a class="el" href="namespaceSPE.html" title="Namespace containing all functions and data classes for this solver. ">SPE</a> equations  <a href="#a4b2905bf10e13fd461321cc46631ed7f">More...</a><br /></td></tr>
<tr class="separator:a4b2905bf10e13fd461321cc46631ed7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc959924a1b080fbe179ae4ac12fc9f"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a6cc959924a1b080fbe179ae4ac12fc9f">set_A_and_Ds</a> (<a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data)</td></tr>
<tr class="memdesc:a6cc959924a1b080fbe179ae4ac12fc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">set A and B matrix for <a class="el" href="namespaceSPE.html" title="Namespace containing all functions and data classes for this solver. ">SPE</a> equations, this is called from set_A_and_Ds(data,alplha) function This is used to set the full 3D operators (y,z, and t)  <a href="#a6cc959924a1b080fbe179ae4ac12fc9f">More...</a><br /></td></tr>
<tr class="separator:a6cc959924a1b080fbe179ae4ac12fc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0365ae4ec2552188705ac7ca8236e8"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a9e0365ae4ec2552188705ac7ca8236e8">set_A_and_Ds_nonlinear</a> (<a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data)</td></tr>
<tr class="memdesc:a9e0365ae4ec2552188705ac7ca8236e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">set A and D matrix linear terms for <a class="el" href="namespaceSPE.html" title="Namespace containing all functions and data classes for this solver. ">SPE</a> equations for nonlinear terms  <a href="#a9e0365ae4ec2552188705ac7ca8236e8">More...</a><br /></td></tr>
<tr class="separator:a9e0365ae4ec2552188705ac7ca8236e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0371c1c635f73834147f3d3bccdc8818"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a0371c1c635f73834147f3d3bccdc8818">set_A_and_Ds_zi</a> (<a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data, PetscScalar &amp;alpha, const PetscInt &amp;zi=0)</td></tr>
<tr class="memdesc:a0371c1c635f73834147f3d3bccdc8818"><td class="mdescLeft">&#160;</td><td class="mdescRight">set A and B matrix linear terms for <a class="el" href="namespaceSPE.html" title="Namespace containing all functions and data classes for this solver. ">SPE</a> equations for zi plane (also sets the permutation matrices to extract u from q, etc.  <a href="#a0371c1c635f73834147f3d3bccdc8818">More...</a><br /></td></tr>
<tr class="separator:a0371c1c635f73834147f3d3bccdc8818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c06d9ab3a145c25fc638396dd0618ba"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a5c06d9ab3a145c25fc638396dd0618ba">set_b</a> (const Mat &amp;B, const Vec &amp;qn, Vec &amp;b)</td></tr>
<tr class="memdesc:a5c06d9ab3a145c25fc638396dd0618ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">set b vector from B and q as b=B*q  <a href="#a5c06d9ab3a145c25fc638396dd0618ba">More...</a><br /></td></tr>
<tr class="separator:a5c06d9ab3a145c25fc638396dd0618ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85d8476e59da7bf85238a201691fd11"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#ab85d8476e59da7bf85238a201691fd11">set_BCs</a> (Mat &amp;A, Vec &amp;b, const PetscInt &amp;ny, const PetscInt &amp;nz)</td></tr>
<tr class="memdesc:ab85d8476e59da7bf85238a201691fd11"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets Boundary Condition equations in Matrix A and vector b in Ax=b linear system for solving the <a class="el" href="namespaceSPE.html" title="Namespace containing all functions and data classes for this solver. ">SPE</a> equations  <a href="#ab85d8476e59da7bf85238a201691fd11">More...</a><br /></td></tr>
<tr class="separator:ab85d8476e59da7bf85238a201691fd11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ea7b83406e5235ff3770407e5f277b"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a36ea7b83406e5235ff3770407e5f277b">set_BCs</a> (<a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data)</td></tr>
<tr class="memdesc:a36ea7b83406e5235ff3770407e5f277b"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets Boundary Condition equations in Matrix A and Matrix B in A+ B*dqdx=0 linear system for solving the <a class="el" href="namespaceSPE.html" title="Namespace containing all functions and data classes for this solver. ">SPE</a> equations  <a href="#a36ea7b83406e5235ff3770407e5f277b">More...</a><br /></td></tr>
<tr class="separator:a36ea7b83406e5235ff3770407e5f277b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0761e83e92a7717959bf0b38d8a50db1"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a0761e83e92a7717959bf0b38d8a50db1">set_Crank_Nicolson_Advance</a> (<a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data, Vec &amp;q, PetscScalar &amp;alpha)</td></tr>
<tr class="memdesc:a0761e83e92a7717959bf0b38d8a50db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">set up Crank-Nicolson advancing matrices A x = b system by creating matrices and setting BCs  <a href="#a0761e83e92a7717959bf0b38d8a50db1">More...</a><br /></td></tr>
<tr class="separator:a0761e83e92a7717959bf0b38d8a50db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78e777495efcb581980cc70f05dd8bd"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#ad78e777495efcb581980cc70f05dd8bd">set_D</a> (const PetscScalar y[], const PetscScalar yP[], const PetscInt &amp;n, Mat &amp;output, <a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data, const PetscInt &amp;order=2, const PetscInt &amp;d=2, const PetscBool &amp;periodic=PETSC_FALSE, const PetscBool &amp;staggered=PETSC_FALSE, const PetscBool &amp;reduce_wall_order=PETSC_TRUE, const PetscBool &amp;uniform=PETSC_TRUE)</td></tr>
<tr class="memdesc:ad78e777495efcb581980cc70f05dd8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">set D matrix operator for specified order and derivative  <a href="#ad78e777495efcb581980cc70f05dd8bd">More...</a><br /></td></tr>
<tr class="separator:ad78e777495efcb581980cc70f05dd8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a3b39e7073f949c61b61b818816d94"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#ad4a3b39e7073f949c61b61b818816d94">set_D_fourier</a> (const PetscInt N, const PetscScalar &amp;T, Mat &amp;output, const PetscInt &amp;d=1)</td></tr>
<tr class="memdesc:ad4a3b39e7073f949c61b61b818816d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">set D matrix operator for specified derivative using fouier collocated points  <a href="#ad4a3b39e7073f949c61b61b818816d94">More...</a><br /></td></tr>
<tr class="separator:ad4a3b39e7073f949c61b61b818816d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888992d480fefdec850a12ad425352a1"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a888992d480fefdec850a12ad425352a1">set_D</a> (<a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data)</td></tr>
<tr class="memdesc:a888992d480fefdec850a12ad425352a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">set D matrices and operators for use in OSS and <a class="el" href="namespaceSPE.html" title="Namespace containing all functions and data classes for this solver. ">SPE</a>  <a href="#a888992d480fefdec850a12ad425352a1">More...</a><br /></td></tr>
<tr class="separator:a888992d480fefdec850a12ad425352a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0588ce5721b33a83761e88f5b552fca5"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a0588ce5721b33a83761e88f5b552fca5">set_Euler_Advance</a> (<a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data, Vec &amp;q, PetscScalar &amp;alpha)</td></tr>
<tr class="memdesc:a0588ce5721b33a83761e88f5b552fca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">set up Euler advancing matrices A x = b system by creating matrices and setting BCs  <a href="#a0588ce5721b33a83761e88f5b552fca5">More...</a><br /></td></tr>
<tr class="separator:a0588ce5721b33a83761e88f5b552fca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2705aa6f107cbc3c58a57729afa4eb"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a9d2705aa6f107cbc3c58a57729afa4eb">set_Mat</a> (const PetscScalar *const *Ain, const PetscInt &amp;n, Mat &amp;A, const InsertMode &amp;addv=ADD_VALUES)</td></tr>
<tr class="memdesc:a9d2705aa6f107cbc3c58a57729afa4eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a matrix from PetscScalar 2D matrix to PETSc Mat type in parallel  <a href="#a9d2705aa6f107cbc3c58a57729afa4eb">More...</a><br /></td></tr>
<tr class="separator:a9d2705aa6f107cbc3c58a57729afa4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f0e2e37e9588b00ab22c3c16b63e0c"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#ac1f0e2e37e9588b00ab22c3c16b63e0c">set_Mat</a> (const PetscScalar &amp;diag, const PetscInt &amp;n, Mat &amp;A, const PetscInt &amp;k=0, const PetscBool &amp;parallel=PETSC_TRUE, const InsertMode &amp;addv=ADD_VALUES)</td></tr>
<tr class="memdesc:ac1f0e2e37e9588b00ab22c3c16b63e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a diagonal of a matrix from scalar  <a href="#ac1f0e2e37e9588b00ab22c3c16b63e0c">More...</a><br /></td></tr>
<tr class="separator:ac1f0e2e37e9588b00ab22c3c16b63e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf61422bdd5011248feb54a8c50f958"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a8cf61422bdd5011248feb54a8c50f958">set_Mat</a> (Mat &amp;A)</td></tr>
<tr class="memdesc:a8cf61422bdd5011248feb54a8c50f958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble matrix.  <a href="#a8cf61422bdd5011248feb54a8c50f958">More...</a><br /></td></tr>
<tr class="separator:a8cf61422bdd5011248feb54a8c50f958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649623e939f681ecfdfab97ec335f4e7"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a649623e939f681ecfdfab97ec335f4e7">set_Mat</a> (const PetscScalar &amp;value, const PetscInt &amp;row, const PetscInt &amp;col, Mat &amp;A, const PetscBool &amp;parallel=PETSC_TRUE, const InsertMode &amp;addv=ADD_VALUES)</td></tr>
<tr class="memdesc:a649623e939f681ecfdfab97ec335f4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a single value in matrix at row,col  <a href="#a649623e939f681ecfdfab97ec335f4e7">More...</a><br /></td></tr>
<tr class="separator:a649623e939f681ecfdfab97ec335f4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a3516f1051ddc7d386a5a6827c04bb"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#af1a3516f1051ddc7d386a5a6827c04bb">set_Mat</a> (const PetscScalar &amp;a, const Mat &amp;Asub, const PetscInt &amp;nsub, Mat &amp;A, const PetscInt &amp;n, const PetscInt &amp;rowoffset=0, const PetscInt &amp;coloffset=0, const InsertMode &amp;addv=ADD_VALUES)</td></tr>
<tr class="memdesc:af1a3516f1051ddc7d386a5a6827c04bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a submatrix Asub in a matrix A  <a href="#af1a3516f1051ddc7d386a5a6827c04bb">More...</a><br /></td></tr>
<tr class="separator:af1a3516f1051ddc7d386a5a6827c04bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4930c580f63a7d293c550bd87371cc"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a8c4930c580f63a7d293c550bd87371cc">set_Mat</a> (const PetscScalar *Ain, const PetscInt &amp;row, const PetscInt &amp;ncols, const PetscInt cols[], Mat &amp;A, const InsertMode &amp;addv=ADD_VALUES)</td></tr>
<tr class="memdesc:a8c4930c580f63a7d293c550bd87371cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a row of PetscScalar to a matrix to PETSc Mat  <a href="#a8c4930c580f63a7d293c550bd87371cc">More...</a><br /></td></tr>
<tr class="separator:a8c4930c580f63a7d293c550bd87371cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae506160ebfdd8d291e7d1ff746fd8c94"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#ae506160ebfdd8d291e7d1ff746fd8c94">set_Mat</a> (const PetscScalar &amp;a, const Mat &amp;Dz, const PetscInt &amp;nz, const PetscInt &amp;ny, const PetscInt &amp;zi, Mat &amp;A, const PetscInt &amp;n, const PetscInt &amp;nvars=4, const PetscInt &amp;rowoffset=0, const PetscInt &amp;coloffset=0, const InsertMode &amp;addv=ADD_VALUES)</td></tr>
<tr class="memdesc:ae506160ebfdd8d291e7d1ff746fd8c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a Dz submatrix into A  <a href="#ae506160ebfdd8d291e7d1ff746fd8c94">More...</a><br /></td></tr>
<tr class="separator:ae506160ebfdd8d291e7d1ff746fd8c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d30488c5591c89c085babdb370f3cc"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a80d30488c5591c89c085babdb370f3cc">set_MatDiagonalScale</a> (const Mat &amp;diag_to_scale, const Mat &amp;Asub, const PetscInt &amp;nsub, Mat &amp;A, const PetscInt &amp;n, const PetscInt &amp;rowoffset=0, const PetscInt &amp;coloffset=0, const InsertMode &amp;addv=ADD_VALUES)</td></tr>
<tr class="memdesc:a80d30488c5591c89c085babdb370f3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a scaled matrix, (rows are scaled by matrix, using A=LA and MatDiagonalScale)  <a href="#a80d30488c5591c89c085babdb370f3cc">More...</a><br /></td></tr>
<tr class="separator:a80d30488c5591c89c085babdb370f3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9301229c88963258914a282fb670c8e2"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a9301229c88963258914a282fb670c8e2">set_Mat_broadcast_from_colVec</a> (Vec &amp;x, PetscInt &amp;n, Mat &amp;A)</td></tr>
<tr class="memdesc:a9301229c88963258914a282fb670c8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a matrix from a column vector (broadcast the column vector to all columns of a matrix Be sure that A is already initialized  <a href="#a9301229c88963258914a282fb670c8e2">More...</a><br /></td></tr>
<tr class="separator:a9301229c88963258914a282fb670c8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff0eed907179a36672cdf0aed204aad"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a7ff0eed907179a36672cdf0aed204aad">set_Mat_from_Vec</a> (Vec &amp;x, PetscInt &amp;ny, PetscInt &amp;nz, PetscInt &amp;rowoffset, Mat &amp;A, const InsertMode &amp;addv=ADD_VALUES)</td></tr>
<tr class="memdesc:a7ff0eed907179a36672cdf0aed204aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a matrix A (large ny*nz*4) from a vector (ny*nz) (used in the diagonals) at a certain rowoffset (between 0-ny*3). Be sure that A is already initialized  <a href="#a7ff0eed907179a36672cdf0aed204aad">More...</a><br /></td></tr>
<tr class="separator:a7ff0eed907179a36672cdf0aed204aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4293a1716beacdc95167277ccb103fe2"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a4293a1716beacdc95167277ccb103fe2">set_Mat_kron</a> (const Mat &amp;A, const Mat &amp;B, Mat &amp;C)</td></tr>
<tr class="memdesc:a4293a1716beacdc95167277ccb103fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker tensor product of two matrices A and B to make C If A is m by n, and B is p by q, then C will be m*p by n*q matrix formed by taking all possible products between the elements of A and the matrix B. See wikipedia for more information <a href="https://en.wikipedia.org/wiki/Kronecker_product">here</a>.  <a href="#a4293a1716beacdc95167277ccb103fe2">More...</a><br /></td></tr>
<tr class="separator:a4293a1716beacdc95167277ccb103fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c401aa166aa5250c6af54bce21b96c"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#ac8c401aa166aa5250c6af54bce21b96c">set_Mat_aPDdim_to_A</a> (PetscScalar a, Mat &amp;P, Mat &amp;D, Mat &amp;A)</td></tr>
<tr class="separator:ac8c401aa166aa5250c6af54bce21b96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9414452878d5614a0b003e77ca2d203"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#ae9414452878d5614a0b003e77ca2d203">set_P</a> (<a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data)</td></tr>
<tr class="memdesc:ae9414452878d5614a0b003e77ca2d203"><td class="mdescLeft">&#160;</td><td class="mdescRight">set permutation matrices and operators for use in OSS and <a class="el" href="namespaceSPE.html" title="Namespace containing all functions and data classes for this solver. ">SPE</a>  <a href="#ae9414452878d5614a0b003e77ca2d203">More...</a><br /></td></tr>
<tr class="separator:ae9414452878d5614a0b003e77ca2d203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256fc5b6620ff47ef08f0b0626d3511c"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a256fc5b6620ff47ef08f0b0626d3511c">set_Vec</a> (const PetscScalar *bin, const PetscInt &amp;n, Vec &amp;b, const PetscBool &amp;parallel=PETSC_TRUE)</td></tr>
<tr class="memdesc:a256fc5b6620ff47ef08f0b0626d3511c"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a vector from PetscScalar 1D vector to PETSc Vec type in parallel  <a href="#a256fc5b6620ff47ef08f0b0626d3511c">More...</a><br /></td></tr>
<tr class="separator:a256fc5b6620ff47ef08f0b0626d3511c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b00247c4785e5e7767be1b01eeb04f"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#ad4b00247c4785e5e7767be1b01eeb04f">set_Vec</a> (Vec &amp;b)</td></tr>
<tr class="memdesc:ad4b00247c4785e5e7767be1b01eeb04f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble b vector.  <a href="#ad4b00247c4785e5e7767be1b01eeb04f">More...</a><br /></td></tr>
<tr class="separator:ad4b00247c4785e5e7767be1b01eeb04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd3fa77d51d217496a0d2cddf9eaedc"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a9cd3fa77d51d217496a0d2cddf9eaedc">set_Vec</a> (const PetscScalar &amp;bin, const PetscInt &amp;n, Vec &amp;b)</td></tr>
<tr class="memdesc:a9cd3fa77d51d217496a0d2cddf9eaedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a vector from PetscScalar to PETSc Vec in location n  <a href="#a9cd3fa77d51d217496a0d2cddf9eaedc">More...</a><br /></td></tr>
<tr class="separator:a9cd3fa77d51d217496a0d2cddf9eaedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753b7d1fbce5bca9fdb8c629d0bbe43e"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a753b7d1fbce5bca9fdb8c629d0bbe43e">set_Vec</a> (const Vec &amp;inVec, const PetscInt &amp;low, const PetscInt &amp;hi, Vec &amp;b)</td></tr>
<tr class="memdesc:a753b7d1fbce5bca9fdb8c629d0bbe43e"><td class="mdescLeft">&#160;</td><td class="mdescRight">set a subvector from larger vector from low to hi indices  <a href="#a753b7d1fbce5bca9fdb8c629d0bbe43e">More...</a><br /></td></tr>
<tr class="separator:a753b7d1fbce5bca9fdb8c629d0bbe43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6f17fb33af6af23fecaa9539946e07"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#abb6f17fb33af6af23fecaa9539946e07">set_Vec_linspace</a> (PetscScalar a, const PetscScalar b, const PetscInt n, PetscScalar y[])</td></tr>
<tr class="memdesc:abb6f17fb33af6af23fecaa9539946e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">set values of y, use linspace similar to matlab, creates on every processor  <a href="#abb6f17fb33af6af23fecaa9539946e07">More...</a><br /></td></tr>
<tr class="separator:abb6f17fb33af6af23fecaa9539946e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b0dc94d0c46540884abfb980c1a0fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a34b0dc94d0c46540884abfb980c1a0fe">trapz</a> (const Vec &amp;q, PetscScalar &amp;I, <a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data)</td></tr>
<tr class="memdesc:a34b0dc94d0c46540884abfb980c1a0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">trapezoidal rule on Vec with ny,nz values  <a href="#a34b0dc94d0c46540884abfb980c1a0fe">More...</a><br /></td></tr>
<tr class="separator:a34b0dc94d0c46540884abfb980c1a0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b3fe437240a42bf4d5f1396f73f062"><td class="memItemLeft" align="right" valign="top">PetscErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#ad4b3fe437240a42bf4d5f1396f73f062">trapz_4nynznt</a> (const Vec &amp;q, PetscScalar &amp;I, <a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data)</td></tr>
<tr class="memdesc:ad4b3fe437240a42bf4d5f1396f73f062"><td class="mdescLeft">&#160;</td><td class="mdescRight">trapezoidal rule on Vec with 4,ny,nz,nt values  <a href="#ad4b3fe437240a42bf4d5f1396f73f062">More...</a><br /></td></tr>
<tr class="separator:ad4b3fe437240a42bf4d5f1396f73f062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9532b226f676d6567d503f4c66be2f24"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#a9532b226f676d6567d503f4c66be2f24">update_Closure</a> (<a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data, Vec &amp;q, Vec &amp;qp1, PetscScalar &amp;alpha, const PetscInt &amp;maxiter=50)</td></tr>
<tr class="memdesc:a9532b226f676d6567d503f4c66be2f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the closure equation \( \int_\Omega \hat{\textbf{q}}^\dagger \hat{\textbf{q}}_x dy \) and output the result This is part of the solution procedure shown in the bottom half of this diagram  <style>div.image img[src="SolutionProcedure.png"]{width:8.5in;}</style>   <a href="#a9532b226f676d6567d503f4c66be2f24">More...</a><br /></td></tr>
<tr class="separator:a9532b226f676d6567d503f4c66be2f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07d10ac9e1461899bb05d30eb41ae43"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSPE.html#ad07d10ac9e1461899bb05d30eb41ae43">update_Nonlinear</a> (<a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;data, Vec &amp;q, Vec &amp;qp1, PetscScalar &amp;alpha_old, PetscScalar &amp;alpha, PetscScalar &amp;Ialpha_old, PetscScalar &amp;Ialpha, const PetscInt &amp;maxiter=50)</td></tr>
<tr class="memdesc:ad07d10ac9e1461899bb05d30eb41ae43"><td class="mdescLeft">&#160;</td><td class="mdescRight">advance the Nonlinear <a class="el" href="namespaceSPE.html" title="Namespace containing all functions and data classes for this solver. ">SPE</a> system one x step  <a href="#ad07d10ac9e1461899bb05d30eb41ae43">More...</a><br /></td></tr>
<tr class="separator:ad07d10ac9e1461899bb05d30eb41ae43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace containing all functions and data classes for this solver. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a015c604f670fd5aa93f19971b0b46d40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPE::_bblf </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>input</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar&#160;</td>
          <td class="paramname"><em>output</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blasius boundary layer function to integrate. Similarity Blasius ODE broken into three coupled equations </p><p class="formulaDsp">
\[ \begin{aligned} f&#39;&#39; &amp;= \int -ff&#39;&#39; d\eta\\ f&#39; &amp;= \int f&#39;&#39; d\eta\\ f &amp;= \int f&#39; d\eta\\ \end{aligned} \]
</p>
<p>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>\([f&#39;&#39;, f&#39;, f]^T\) state at \( \eta_i \) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>\([f&#39;&#39;, f&#39;, f]^T\) state at \(\eta_{i+1} \) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a987d1c140c3de2c40e5fc4569f6f85d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::Ax_b </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar *const *&#160;</td>
          <td class="paramname"><em>Ain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>bin</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves \(x\) in \(Ax=b\) linalg problem using PETSc in parallel Useful for solving small systems of equations, such as finite difference coefficients for given stencils. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Ain</td><td>input of 2D \(A\) matrix in \(Ax=b\) (must be dynamic pointer to pointer) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>vector of \(x\) in \(Ax=b\) (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bin</td><td>vector of \(b\) in \(Ax=b\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>n size of vectors or nxn matrix \(A\) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9bc6a97a8a7ebfb8f40f1862ec2c71ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::Ax_b </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves \(x\) in \(Ax=b\) linalg problem using PETSc in parallel. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input of A matrix in \(Ax=b\) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>vector of \(x\) in \(Ax=b\) (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>vector of \(b\) in \(Ax=b\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>n size of vectors or nxn matrix \(A\) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f26ce4b77bbab2090739d54da585bc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::Ax_kBx </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>kr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>ki</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>xr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar&#160;</td>
          <td class="paramname"><em>target</em> = <code>0.54213+0.082968*PETSC_i</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscInt&#160;</td>
          <td class="paramname"><em>nev</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EPSWhich&#160;</td>
          <td class="paramname"><em>which</em> = <code>EPS_TARGET_MAGNITUDE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves \(x\) in \(Ax=kBx\) eigenvalue problem using SLEPc in parallel. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input of A matrix in \(Ax=kBx\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>input of B matrix in \(Ax=kBx\) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">kr</td><td>real part of eigenvalue </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ki</td><td>imag part of eigenvalue </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xr</td><td>vector of \(x\) in \(Ax=kBx\) (already initialized) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xi</td><td>vector of \(x\) in \(Ax=kBx\) (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>target eigenvalue to solve around using the which parameter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nev</td><td>number of eigenvalues to compute </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">which</td><td>portion of spectrum to be sought </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a66a86a4b0bc0a7380655c721d2f7e3b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPE::base_flow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set plane channel or blasius boundary layer flow velocity variables \(U, U_x, U_y,\) and etc Note: type_base_flow has an integer flag that corresponds with the following flow types </p>
<ul>
<li>1 - Poisuille channel flow</li>
<li>2 - Blasius Flat-Plate</li>
<li>3 - <a class="el" href="namespaceSPE.html" title="Namespace containing all functions and data classes for this solver. ">SPE</a> Boundary Layer equations with nonlinear forcing terms for Mean Flow Distortion</li>
<li>4 - Read U,V,P from DNS data set located in the file sets of read_matlab_filename + "_Base_Flow/Base_Flow_istep_%i.dat"</li>
<li>5 - <a class="el" href="namespaceSPE.html" title="Namespace containing all functions and data classes for this solver. ">SPE</a> Boundary Layer equations with nonlinear forcing terms for Mean Flow Distortion for semi-staggered grid  use this once to set the vectors with the velocity of plane channel flow (max u=1) <dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data from class passed in and out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73c3f1eb587408213001e6a5ed8c82ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPE::base_flow_dim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use this after base_flow(data) call to set the ny matrices to size dim. So U is set into U_dim. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data from class passed in and out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b473e31d0e9421cdc887c11e0baf792"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPE::calc_Closure </td>
          <td>(</td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>qp1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the closure equation \( \int_{\Omega} \hat{\textbf{q}}^\dagger \hat{\textbf{q}}_x d\Omega \) and output the result </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>output integral value </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to store values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>q at last marching step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qp1</td><td>q at current marching step </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a116be7eaa0729c0d593458e88f0daff9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPE::calc_L2 </td>
          <td>(</td>
          <td class="paramtype">PetscReal &amp;&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscInt&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NormType&#160;</td>
          <td class="paramname"><em>type</em> = <code>NORM_2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the \( L_2 \) norm of the difference between \(x_1\) and \(x_2\) vectors and return </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">error</td><td>\(L_2\) norm of the difference between \(x_1\) and \(x_2\) vectors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x1</td><td>\(x_1\) vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x2</td><td>\(x_2\) vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of vectors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>type of norm (default NORM_2 \(\sqrt{\sum |x_1-x_2|^2}\) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab462173f3b98c1b085f7411036ac7b4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPE::calc_L2 </td>
          <td>(</td>
          <td class="paramtype">PetscReal &amp;&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscInt&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NormType&#160;</td>
          <td class="paramname"><em>type</em> = <code>NORM_2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the \( L_2 \) norm of the difference between \(x_1\) and \(x_2\) matrix diagonals and return </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">error</td><td>\(L_2\) norm of the difference between \(x_1\) and \(x_2\) vectors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x1</td><td>\(x_1\) diagonal matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x2</td><td>\(x_2\) diagonal matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of vectors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>type of norm (default NORM_2 \(\sqrt{\sum |x_1-x_2|^2}\) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4baf182ac98c709701d2ac22268516a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPE::calc_LST </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar&#160;</td>
          <td class="paramname"><em>target_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>qp1_OSS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>qp1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the Local Stability Theory (LST) Orr-Sommerfeld Squire equations in primitive variables at this x-location and store the alpha and qp1 of the target spatial values. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="set__A__and__B__OSS__zi_8hpp.html">set_A_and_B_OSS_zi.hpp</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to store values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_alpha</td><td>target alpha guess </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">alpha</td><td>alpha from OSS solver </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qp1_OSS</td><td>eigenvector of size data.dimOSS </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qp1</td><td>eigenvector of size data.dim </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6146385b9d4b24a455bb34a37c602ac2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPE::Create_grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar&#160;</td>
          <td class="paramname"><em>deltay</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create y and z grid and stretch in y direction using stretching if deltay is nonzero </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to hold data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deltay</td><td>stretching in y direction using hyperbolic stretching function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee145e1de6014859604b6470f908a5da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned SPE::factorial </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the factorial of an integer </p>
<dl class="section return"><dt>Returns</dt><dd>n! </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">n</td><td>input integer to perform factorial on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac83096d834607fbcff7dea5c1b2be52f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::get_D_Coeffs </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>s</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve arbitrary stencil points s of length N with order of derivatives d&lt;N can be obtained from equation on MIT website <a href="http://web.media.mit.edu/~crtaylor/calculator.html">http://web.media.mit.edu/~crtaylor/calculator.html</a> where the accuracy is determined as the usual form O(h^(N-d)) </p>
<p>ierr from Ax=b solver </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>array of stencil points e.g. [-3,-2,-1,0,1] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of stencil </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>output of coefficient values for the given stencil (uninitialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>order of desired derivative (default=2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba10b99628bf94467786d42692daed8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPE::Init_Mat </td>
          <td>(</td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a Matrix A to be of size nxn. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>A matrix to initialize in MPI (uninitialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of global rows and columns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb71547055ae4dd811cfc9478b0dbbc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPE::Init_Mat </td>
          <td>(</td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a Matrix A to be of size mxn. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>A matrix to initialize in MPI (uninitialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of global rows </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of global columns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a856eb47a60d74969a9894326c2ad9bb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPE::Init_Vec </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a vector x to be of size n. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td>x vector to initialize in MPI (uninitialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad28f22e36aaf616f05cfd6618a0411c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::map_D </td>
          <td>(</td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>yVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>order</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscBool &amp;&#160;</td>
          <td class="paramname"><em>periodic</em> = <code>PETSC_FALSE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscBool &amp;&#160;</td>
          <td class="paramname"><em>staggered</em> = <code>PETSC_FALSE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscBool &amp;&#160;</td>
          <td class="paramname"><em>reduce_wall_order</em> = <code>PETSC_TRUE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>map D matrix operator for specified order and derivative, for a non-uniform mesh </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">output</td><td>matrix(n by n) dth derivative of order O(h^order) assuming uniform xi spacing coming in (initialized), then output a non-uniform derivative w.r.t. y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data class to have flags </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>length of y values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yVec</td><td>y non-uniform data pts of interest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>order of accuracy desired (assuming even e.g. 2,4,6,...) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>dth derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">periodic</td><td>periodic boundary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">staggered</td><td>if setting staggered pressure derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reduce_wall_order</td><td>reduce the order of accuracy at the wall? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a11073a2d25024515f3df17fbf68318f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscErrorCode SPE::printBaseNonlinearIter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscReal&#160;</td>
          <td class="paramname"><em>basenonlinear_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscInt&#160;</td>
          <td class="paramname"><em>basenonlinear_iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>print iteration residuals to screen from baseflow nonlinear iterations </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data class storing iterations and residual values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basenonlinear_error</td><td>nonlinear error for the baseflow </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basenonlinear_iter</td><td>base flow nonlinear iteration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a303746d7ec502ae5fd001d4fd1e9dcc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscErrorCode SPE::printClosureIter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>print iteration residuals to screen from update_Closure iterations </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data class storing iterations and residual values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4cef2622446eec7da75349151b7a7892"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SPE::printHeaderIter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>print iteration residuals header to screen </p>

</div>
</div>
<a class="anchor" id="ade6db8781df123af6a423aafd4de8dbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscErrorCode SPE::printInt </td>
          <td>(</td>
          <td class="paramtype">const PetscInt&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>name</em>[] = <code>&quot;x&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print PetscInt variable to screen. </p>
<dl class="section return"><dt>Returns</dt><dd>ierr from PetscErrorCode of PetscPrintf </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>PetscScalar array to print to screen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of scalar array to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of variable to output default to 'x' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad1e454a2558010d2c245324c4307384e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::printMatASCII </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>name</em>[] = <code>&quot;printMatASCII.txt&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscViewerFormat&#160;</td>
          <td class="paramname"><em>format</em> = <code>PETSC_VIEWER_DEFAULT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>view Petsc Mat variable to ASCII file </p>
<ul>
<li>Helpful runtime option:</li>
</ul>
<p>-draw_pause &lt;pause&gt; : sets time (in seconds) that the program pauses after PetscDrawPause() has been called (0 is default, -1 implies until user input). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Petsc Mat nxn matrix to print to screen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>filename to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>format for viewer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a985ae79ebcb0a4ac6a998e412df88955"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::printMatASCII </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscViewerFormat&#160;</td>
          <td class="paramname"><em>format</em> = <code>PETSC_VIEWER_DEFAULT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>view Petsc Mat variable to ASCII file </p>
<ul>
<li>Helpful runtime option:</li>
</ul>
<p>-draw_pause &lt;pause&gt; : sets time (in seconds) that the program pauses after PetscDrawPause() has been called (0 is default, -1 implies until user input). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Petsc Mat nxn matrix to print to screen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>filename to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>format for viewer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="affdd4cf955d3b3d1fa6e592cd2389efc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SPE::printMatGetDiagonalASCII </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>name</em>[] = <code>&quot;printMatGetDiagonalASCII.txt&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscViewerFormat&#160;</td>
          <td class="paramname"><em>format</em> = <code>PETSC_VIEWER_ASCII_MATLAB</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>print diagonal of Petsc Mat variable to ASCII file </p>
<ul>
<li>Helpful runtime option:</li>
</ul>
<p>-draw_pause &lt;pause&gt; : sets time (in seconds) that the program pauses after PetscDrawPause() has been called (0 is default, -1 implies until user input). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Petsc Mat nxn matrix to print to screen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>filename to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>format for viewer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4609deb337d7f056df3a3933e4e3fb6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::printMatView </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>name</em>[] = <code>&quot;A&#160;viewer&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscViewerFormat&#160;</td>
          <td class="paramname"><em>format</em> = <code>PETSC_VIEWER_DEFAULT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>view Petsc Mat variable to screen Open an X-window viewer. Note that we specify the same communicator for the viewer as we used for the distributed vector (PETSC_COMM_WORLD). </p>
<ul>
<li>Helpful runtime option:</li>
</ul>
<p>-draw_pause &lt;pause&gt; : sets time (in seconds) that the program pauses after PetscDrawPause() has been called (0 is default, -1 implies until user input). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Petsc Mat nxn matrix to print to screen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of variable to output default to 'A' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>format for viewer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0115f2a12d942e4fa08ab8e2f01b975"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscErrorCode SPE::printNonlinearIter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>print iteration residuals to screen from update_Nonlinear iterations </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data class storing iterations and residual values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab440e97505010fd1d1448a2f5efc8c60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscErrorCode SPE::printReal </td>
          <td>(</td>
          <td class="paramtype">const PetscReal&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>name</em>[] = <code>&quot;x&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscViewer&#160;</td>
          <td class="paramname"><em>viewer</em> = <code>PETSC_VIEWER_STDOUT_WORLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print PetscReal variable to screen. </p>
<dl class="section return"><dt>Returns</dt><dd>ierr from PetscErrorCode of PetscPrintf </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>PetscReal array to print to screen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of scalar array to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of variable to output default to 'x' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewer</td><td>format for viewer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab45ff39ed31723e63ae72bf2b2f5fd73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscErrorCode SPE::printScalar </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>name</em>[] = <code>&quot;x&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscViewer&#160;</td>
          <td class="paramname"><em>viewer</em> = <code>PETSC_VIEWER_STDOUT_WORLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print PetscScalar variable to screen. </p>
<dl class="section return"><dt>Returns</dt><dd>ierr from PetscErrorCode of PetscPrintf </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>PetscScalar array to print to screen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of scalar array to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of variable to output default to 'x' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewer</td><td>format for viewer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70b7e7d6563ccede850e1f0bf63a674d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscErrorCode SPE::printVec </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>name</em>[] = <code>&quot;x&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print Vec from PETSc type variable to screen. </p>
<dl class="section return"><dt>Returns</dt><dd>ierr from PetscErrorCode of PetscPrintf </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Vec array to print to screen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of scalar array to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of variable to output default to 'x' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b95845145ea996b125784e1488733bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SPE::printVecASCII </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>name</em>[] = <code>&quot;printVecASCII.txt&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscViewerFormat&#160;</td>
          <td class="paramname"><em>format</em> = <code>PETSC_VIEWER_ASCII_MATLAB</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>view Petsc Vec variable to ASCII file </p>
<ul>
<li>Helpful runtime option:</li>
</ul>
<p>-draw_pause &lt;pause&gt; : sets time (in seconds) that the program pauses after PetscDrawPause() has been called (0 is default, -1 implies until user input). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Petsc Vec 1xn vector to print to screen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>filename to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>format for viewer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab542316e02bd55571faece4af34d5ed2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SPE::printVecView </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>name</em>[] = <code>&quot;x&#160;viewer&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscViewerFormat&#160;</td>
          <td class="paramname"><em>format</em> = <code>PETSC_VIEWER_DEFAULT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>view PetscVec variable to screen Open an X-window viewer. Note that we specify the same communicator for the viewer as we used for the distributed vector (PETSC_COMM_WORLD). </p>
<ul>
<li>Helpful runtime option:</li>
</ul>
<p>-draw_pause &lt;pause&gt; : sets time (in seconds) that the program pauses after PetscDrawPause() has been called (0 is default, -1 implies until user input). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>PetscScalar array to print to screen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of variable to output default to 'x' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>format for viewer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a58acf300ce545c131aa45a572e57ad35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPE::Read_input_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const&#160;</td>
          <td class="paramname"><em>buff</em>[] = <code>&quot;input_file.json&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read an input file written in json format. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to hold data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>filename of binary to read (output of python script </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6dfc5d5b35399aa4402d1eb5e677f176"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPE::Read_MatLab </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>buff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read input matrix and vectors input data from a matlab files (be sure this uses the PetscBinaryWrite() MatLab function) Reads and sets y, yVec, z, zVec, q, qp1, alpha, Deltay, and Deltaz quantities in the <a class="el" href="namespaceSPE.html" title="Namespace containing all functions and data classes for this solver. ">SPE</a> class. </p>
<dl class="section return"><dt>Returns</dt><dd>ierr </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to hold data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>filename (without endings) of binary matlab files to read (output of matlab script using PetscSpecific binary write functions and fwrite) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a27420a6628d48ef5879fb5074428401b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscErrorCode SPE::Read_MatLabMat </td>
          <td>(</td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>buff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read complex scalar matrix from a matlab file (be sure this uses the PetscBinaryWrite() MatLab function) </p>
<dl class="section return"><dt>Returns</dt><dd>ierr </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>complex scalar matrix to return after reading file (uninitialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>filename of binary matlab file to read (output of matlab script using PetscSpecific binary write functions) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad86cff5c8b04a8713b4bb180c6c1bc84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscErrorCode SPE::Read_MatLabVec </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>buff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read complex scalar vector from a matlab file (be sure this uses the PetscBinaryWrite() MatLab function) </p>
<dl class="section return"><dt>Returns</dt><dd>ierr </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>complex scalar vector to return after reading file (uninitialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>filename of binary matlab file to read (output of matlab script using PetscSpecific binary write functions) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af148ab7e7fc4ec635bdc8a028fd0ef6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPE::Read_q </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>buff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read q from a tofile output from python. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to hold data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>filename of binary to read (output of python script) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e8fbf8253402387e0615ec07e12aa02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPE::Read_q </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>buff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read q from a tofile output from python. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">output</td><td>vector to return after reading file (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>int size of vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>filename of binary to read (output of python script) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3921882dcf3896f32283eb812f99bee5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPE::Read_q </td>
          <td>(</td>
          <td class="paramtype">PetscScalar&#160;</td>
          <td class="paramname"><em>output</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>buff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read y from a tofile output from python. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>vector to return after reading file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>int size of vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>filename of binary to read (output of python script) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad93ece36a6dba0035fad72abb73080e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPE::Read_q </td>
          <td>(</td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>buff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read complex scalar from a tofile output from python. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>complex scalar to return after reading file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>filename of binary to read (output of python script) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa07dee0f41e4f927ab226733077b8164"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_A_and_B_OSS_zi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>zi</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set A and B matrix for Orr-Sommerfeld equations for zi plane Note that the wavelike ansatz is \(u=\hat{u}(y,z) \exp (i (-\omega t + \alpha x))\) </p><p class="formulaDsp">
\[ \begin{aligned} (-i \omega - \frac{1}{Re}(\partial_y^2 + \partial_z^2))\hat{u} + U&#39; \hat{v} &amp;= \alpha (-i \hat{P} - \frac{i}{Re}(\partial_y \hat{v} + \partial_z \hat{w}) - iU \hat{u})\\ (-i \omega - \frac{1}{Re}(\partial_y^2 + \partial_z^2))\hat{v} + \partial_y \hat{P} &amp;= \alpha (- \frac{1}{Re}(\alpha \hat{v}) - iU \hat{v})\\ (\alpha \hat{v}) &amp;= \alpha \cdot \hat{v}\\ (-i \omega - \frac{1}{Re}(\partial_y^2 + \partial_z^2))\hat{w} + \partial_z \hat{P} &amp;= \alpha (- \frac{1}{Re}(\alpha \hat{w}) - iU \hat{w})\\ (\alpha \hat{w}) &amp;= \alpha \cdot \hat{w}\\ \partial_y \hat{v} + \partial_z \hat{w} &amp;= \alpha (-i \hat{u})\\ \end{aligned}\]
</p>
<p> Where we have </p><p class="formulaDsp">
\[ \begin{aligned} \mathbf{z}_i= \begin{bmatrix} \hat{u}\\ \alpha \hat{v}\\ \hat{v}\\ \alpha \hat{w}\\ \hat{w}\\ \hat{P} \end{bmatrix}_{z=z(i)} \textrm{ and } &amp; \mathbf{q} = \begin{bmatrix} \mathbf{z}_1\\ \mathbf{z}_2\\ \vdots \\ \mathbf{z}_{nz - 1}\\ \mathbf{z}_{nz}\\ \end{bmatrix}\\ \end{aligned}\]
</p>
<p> To solve the spatial eigenvalue problem \(\mathbf{\mathcal{A}q} = \alpha \mathbf{\mathcal{B}q}\) </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to store values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zi</td><td>zi plane of matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b2905bf10e13fd461321cc46631ed7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_A_and_Ds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set A and B matrix for <a class="el" href="namespaceSPE.html" title="Namespace containing all functions and data classes for this solver. ">SPE</a> equations </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class containing all matrices, vectors, scalars, and problem size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>\( \alpha \) eigenvalue from previous iteration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6cc959924a1b080fbe179ae4ac12fc9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_A_and_Ds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set A and B matrix for <a class="el" href="namespaceSPE.html" title="Namespace containing all functions and data classes for this solver. ">SPE</a> equations, this is called from set_A_and_Ds(data,alplha) function This is used to set the full 3D operators (y,z, and t) </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class containing all matrices, vectors, scalars, and problem size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e0365ae4ec2552188705ac7ca8236e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_A_and_Ds_nonlinear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set A and D matrix linear terms for <a class="el" href="namespaceSPE.html" title="Namespace containing all functions and data classes for this solver. ">SPE</a> equations for nonlinear terms </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to store values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0371c1c635f73834147f3d3bccdc8818"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_A_and_Ds_zi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>zi</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set A and B matrix linear terms for <a class="el" href="namespaceSPE.html" title="Namespace containing all functions and data classes for this solver. ">SPE</a> equations for zi plane (also sets the permutation matrices to extract u from q, etc. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to store values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>eigenvalue from previous iteration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zi</td><td>zi plane of matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5c06d9ab3a145c25fc638396dd0618ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_b </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>qn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set b vector from B and q as b=B*q </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>B matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qn</td><td>qn vector to multiply </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>b Vec (already initialized) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab85d8476e59da7bf85238a201691fd11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_BCs </td>
          <td>(</td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>nz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets Boundary Condition equations in Matrix A and vector b in Ax=b linear system for solving the <a class="el" href="namespaceSPE.html" title="Namespace containing all functions and data classes for this solver. ">SPE</a> equations </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>A matrix (already initialized) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>b Vec (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ny</td><td>size of y array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nz</td><td>size of z array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a36ea7b83406e5235ff3770407e5f277b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_BCs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets Boundary Condition equations in Matrix A and Matrix B in A+ B*dqdx=0 linear system for solving the <a class="el" href="namespaceSPE.html" title="Namespace containing all functions and data classes for this solver. ">SPE</a> equations </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data class for flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0761e83e92a7717959bf0b38d8a50db1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_Crank_Nicolson_Advance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set up Crank-Nicolson advancing matrices A x = b system by creating matrices and setting BCs </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to store values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>q at last marching step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>eigenvalue from previous step </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad78e777495efcb581980cc70f05dd8bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_D </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>y</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>yP</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>order</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscBool &amp;&#160;</td>
          <td class="paramname"><em>periodic</em> = <code>PETSC_FALSE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscBool &amp;&#160;</td>
          <td class="paramname"><em>staggered</em> = <code>PETSC_FALSE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscBool &amp;&#160;</td>
          <td class="paramname"><em>reduce_wall_order</em> = <code>PETSC_TRUE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscBool &amp;&#160;</td>
          <td class="paramname"><em>uniform</em> = <code>PETSC_TRUE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set D matrix operator for specified order and derivative </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<p>if odd derivative</p>
<p>if odd derivative</p>
<p>if odd derivative</p>
<p>if odd derivative </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>array of y values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yP</td><td>array of y values of semi-staggered pressure locations (size ny-1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>length of y values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>matrix(n by n) dth derivative of order O(h^order) assuming uniform y spacing (uninitialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data class to have flags </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>order of accuracy desired (assuming even e.g. 2,4,6,...) (default 2) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>dth derivative (default 2) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">periodic</td><td>periodic boundary (default false) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">staggered</td><td>if setting staggered pressure derivative (default false) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reduce_wall_order</td><td>reduce the order of accuracy at the wall? (default true) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uniform</td><td>uniform mesh? (default true) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a888992d480fefdec850a12ad425352a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set D matrices and operators for use in OSS and <a class="el" href="namespaceSPE.html" title="Namespace containing all functions and data classes for this solver. ">SPE</a> </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data class to have flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4a3b39e7073f949c61b61b818816d94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::SPE::set_D_fourier </td>
          <td>(</td>
          <td class="paramtype">const PetscInt&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>d</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set D matrix operator for specified derivative using fouier collocated points </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>length of collocated points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>period of y values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>matrix(n by n) dth derivative of order O(h^order) assuming uniform y spacing (uninitialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>dth derivative (default 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0588ce5721b33a83761e88f5b552fca5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_Euler_Advance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set up Euler advancing matrices A x = b system by creating matrices and setting BCs </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to store values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>q at last marching step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>eigenvalue \( \alpha \) from the previous iteration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a81919c87d8b6ffe6da239599c3d2cf2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPE::set_input_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJson_1_1Value.html">Json::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>buff</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscInt &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>take <a class="el" href="namespaceJson.html" title="JSON (JavaScript Object Notation). ">Json</a> data and save it to value if it exists </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td><a class="el" href="namespaceJson.html" title="JSON (JavaScript Object Notation). ">Json</a> file after reading </td></tr>
    <tr><td class="paramname">buff</td><td>matching key to check if it exits, if it does, set the value </td></tr>
    <tr><td class="paramname">v</td><td>value to set if key is matching </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb9c276163bcef0fcff79ced71838741"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPE::set_input_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJson_1_1Value.html">Json::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>buff</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscReal &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>take <a class="el" href="namespaceJson.html" title="JSON (JavaScript Object Notation). ">Json</a> data and save it to value if it exists </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td><a class="el" href="namespaceJson.html" title="JSON (JavaScript Object Notation). ">Json</a> file after reading </td></tr>
    <tr><td class="paramname">buff</td><td>matching key to check if it exits, if it does, set the value </td></tr>
    <tr><td class="paramname">v</td><td>value to set if key is matching </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee53c952e93397330ab021f836246e5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPE::set_input_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJson_1_1Value.html">Json::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>buff</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>take <a class="el" href="namespaceJson.html" title="JSON (JavaScript Object Notation). ">Json</a> data and save it to value if it exists </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td><a class="el" href="namespaceJson.html" title="JSON (JavaScript Object Notation). ">Json</a> file after reading </td></tr>
    <tr><td class="paramname">buff</td><td>matching key to check if it exits, if it does, set the value </td></tr>
    <tr><td class="paramname">v</td><td>value to set if key is matching </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5166674d41c473ffd01fa89e68675630"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPE::set_input_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJson_1_1Value.html">Json::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>buff</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscBool &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>take <a class="el" href="namespaceJson.html" title="JSON (JavaScript Object Notation). ">Json</a> data and save it to value if it exists </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td><a class="el" href="namespaceJson.html" title="JSON (JavaScript Object Notation). ">Json</a> file after reading </td></tr>
    <tr><td class="paramname">buff</td><td>matching key to check if it exits, if it does, set the value </td></tr>
    <tr><td class="paramname">v</td><td>value to set if key is matching </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09c5f0b0fb66915b97905763bf9406e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPE::set_input_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJson_1_1Value.html">Json::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>buff</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>take <a class="el" href="namespaceJson.html" title="JSON (JavaScript Object Notation). ">Json</a> data and save it to value if it exists </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td><a class="el" href="namespaceJson.html" title="JSON (JavaScript Object Notation). ">Json</a> file after reading </td></tr>
    <tr><td class="paramname">buff</td><td>matching key to check if it exits, if it does, set the value </td></tr>
    <tr><td class="paramname">v</td><td>value tos et if key is matching (string) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad71d6dbe78287c061e726471ba643923"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPE::set_input_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJson_1_1Value.html">Json::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>buff</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>take <a class="el" href="namespaceJson.html" title="JSON (JavaScript Object Notation). ">Json</a> data and save it to value if it exists </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td><a class="el" href="namespaceJson.html" title="JSON (JavaScript Object Notation). ">Json</a> file after reading </td></tr>
    <tr><td class="paramname">buff</td><td>matching key to check if it exits, if it does, set the value </td></tr>
    <tr><td class="paramname">v</td><td>value tos et if key is matching (string) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d2705aa6f107cbc3c58a57729afa4eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_Mat </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar *const *&#160;</td>
          <td class="paramname"><em>Ain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InsertMode &amp;&#160;</td>
          <td class="paramname"><em>addv</em> = <code>ADD_VALUES</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a matrix from PetscScalar 2D matrix to PETSc Mat type in parallel </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Ain</td><td>Matrix set on all processors as 2D array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of nxn matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>Mat to SetValues and output in parallel (uninitialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addv</td><td>insert values or add values to matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac1f0e2e37e9588b00ab22c3c16b63e0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_Mat </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscBool &amp;&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>PETSC_TRUE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InsertMode &amp;&#160;</td>
          <td class="paramname"><em>addv</em> = <code>ADD_VALUES</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a diagonal of a matrix from scalar </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">diag</td><td>scalar value to set as diagonal in matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of nxn matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Mat to SetValues and output in parallel (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>diagonal offset in matrix (k=0 is main diagonal, k&gt;0 is above main diagonal, k&lt;0 is below main diagonal) default is 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parallel</td><td>set the matrix using Istart and Iend </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addv</td><td>insert values or add values to matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8cf61422bdd5011248feb54a8c50f958"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_Mat </td>
          <td>(</td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Mat to assemble (already initialized) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a649623e939f681ecfdfab97ec335f4e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_Mat </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscBool &amp;&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>PETSC_TRUE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InsertMode &amp;&#160;</td>
          <td class="paramname"><em>addv</em> = <code>ADD_VALUES</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a single value in matrix at row,col </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>value to set in Mat A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>specified global row in Mat A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>specified global col in Mat A </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Matrix A to set value (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parallel</td><td>do this in parallel? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addv</td><td>insert values or add values to matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1a3516f1051ddc7d386a5a6827c04bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_Mat </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>Asub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>nsub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>rowoffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>coloffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InsertMode &amp;&#160;</td>
          <td class="paramname"><em>addv</em> = <code>ADD_VALUES</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a submatrix Asub in a matrix A </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>premultple to Asub </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Asub</td><td>sub matrix to set into mat </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nsub</td><td>nxn size of square sub matrix Asub </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Matrix A to set value (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of square Matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowoffset</td><td>start inserting Asub in A starting at rowoffset row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coloffset</td><td>start inserting Asub in A starting at coloffset column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addv</td><td>insert values or add values to matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c4930c580f63a7d293c550bd87371cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_Mat </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar *&#160;</td>
          <td class="paramname"><em>Ain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt&#160;</td>
          <td class="paramname"><em>cols</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InsertMode &amp;&#160;</td>
          <td class="paramname"><em>addv</em> = <code>ADD_VALUES</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a row of PetscScalar to a matrix to PETSc Mat </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Ain</td><td>array to set in row of matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>row to set in matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ncols</td><td>ncols of array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cols</td><td>cols to set in matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Mat to SetValues and output in parallel (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addv</td><td>insert values or add values to matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae506160ebfdd8d291e7d1ff746fd8c94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_Mat </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>Dz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>zi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>nvars</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>rowoffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>coloffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InsertMode &amp;&#160;</td>
          <td class="paramname"><em>addv</em> = <code>ADD_VALUES</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a Dz submatrix into A </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>premultple to Dz </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Dz</td><td>sub matrix to set into mat in z direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nz</td><td>\(n_z \times n_z \) size of square sub matrix Dz </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ny</td><td>length of \( y \) array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zi</td><td>which \( z \) plane you are looking at </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Matrix A to set value (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of square Matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nvars</td><td>number of variables in vector 4 if (u,v,w,P) or 6 if (u, v, av, w, aw, P) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowoffset</td><td>start inserting Asub in A starting at rowoffset row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coloffset</td><td>start inserting Asub in A starting at coloffset column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addv</td><td>insert values or add values to matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8c401aa166aa5250c6af54bce21b96c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_Mat_aPDdim_to_A </td>
          <td>(</td>
          <td class="paramtype">PetscScalar&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Scalar to multiply Ddim by </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>Permutation matrix to change block diagonal to fit desired input into A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>Derivative matrix (or similar) of size A </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Matrix that A += a*P (@ is matrix multiply) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9301229c88963258914a282fb670c8e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_Mat_broadcast_from_colVec </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a matrix from a column vector (broadcast the column vector to all columns of a matrix Be sure that A is already initialized </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>column Vec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>length of Vec </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>Matrix of size nxn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ff0eed907179a36672cdf0aed204aad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_Mat_from_Vec </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscInt &amp;&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscInt &amp;&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscInt &amp;&#160;</td>
          <td class="paramname"><em>rowoffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InsertMode &amp;&#160;</td>
          <td class="paramname"><em>addv</em> = <code>ADD_VALUES</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a matrix A (large ny*nz*4) from a vector (ny*nz) (used in the diagonals) at a certain rowoffset (between 0-ny*3). Be sure that A is already initialized </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>column Vec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ny</td><td>length of Vec is ny*nz </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nz</td><td>length of Vec is ny*nz </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowoffset</td><td>start inserting Vec in A starting at rowoffset row </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Matrix of size ny*nz*4 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addv</td><td>insert values or add values to matrix A (default ADD_VALUES) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4293a1716beacdc95167277ccb103fe2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_Mat_kron </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kronecker tensor product of two matrices A and B to make C If A is m by n, and B is p by q, then C will be m*p by n*q matrix formed by taking all possible products between the elements of A and the matrix B. See wikipedia for more information <a href="https://en.wikipedia.org/wiki/Kronecker_product">here</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>First matrix \(m \times n\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>Second matrix \(p \times q\) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>output matrix \(mp \times n*q\) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80d30488c5591c89c085babdb370f3cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_MatDiagonalScale </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>diag_to_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>Asub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>nsub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>rowoffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>coloffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InsertMode &amp;&#160;</td>
          <td class="paramname"><em>addv</em> = <code>ADD_VALUES</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a scaled matrix, (rows are scaled by matrix, using A=LA and MatDiagonalScale) </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">diag_to_scale</td><td>premultple to scale the rows of Asub </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Asub</td><td>sub matrix to set into mat </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nsub</td><td>nxn size of square sub matrix Asub </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Matrix A to set value (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of square Matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowoffset</td><td>start inserting Asub in A starting at rowoffset row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coloffset</td><td>start inserting Asub in A starting at coloffset column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addv</td><td>insert values or add values to matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae9414452878d5614a0b003e77ca2d203"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set permutation matrices and operators for use in OSS and <a class="el" href="namespaceSPE.html" title="Namespace containing all functions and data classes for this solver. ">SPE</a> </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data class to have flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a256fc5b6620ff47ef08f0b0626d3511c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_Vec </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar *&#160;</td>
          <td class="paramname"><em>bin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscBool &amp;&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>PETSC_TRUE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a vector from PetscScalar 1D vector to PETSc Vec type in parallel </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bin</td><td>array set on all processors as 1D array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of n array </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>Vec to SetValues and output in parallel (already initialized) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parallel</td><td>set in parallel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4b00247c4785e5e7767be1b01eeb04f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_Vec </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble b vector. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>array to assemble on all processors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9cd3fa77d51d217496a0d2cddf9eaedc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_Vec </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>bin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a vector from PetscScalar to PETSc Vec in location n </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bin</td><td>scalar to set into Vec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>location to put into Vec </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>Vec to SetValues (already initialized) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a753b7d1fbce5bca9fdb8c629d0bbe43e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_Vec </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>inVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set a subvector from larger vector from low to hi indices </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inVec</td><td>larger vec to copy values from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">low</td><td>lower bound </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hi</td><td>upper bound </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>Vec to SetValues and output (already initialized) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb6f17fb33af6af23fecaa9539946e07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt SPE::set_Vec_linspace </td>
          <td>(</td>
          <td class="paramtype">PetscScalar&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar&#160;</td>
          <td class="paramname"><em>y</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set values of y, use linspace similar to matlab, creates on every processor </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>lower bound </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>upper bound </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>upper bound </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">y</td><td>linspace output vector (already initialized to right size) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a34b0dc94d0c46540884abfb980c1a0fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPE::trapz </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>trapezoidal rule on Vec with ny,nz values </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>Vector to integrate </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>value of integration </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>data class to store Trapzy and Trapzz value and flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4b3fe437240a42bf4d5f1396f73f062"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscErrorCode SPE::trapz_4nynznt </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>trapezoidal rule on Vec with 4,ny,nz,nt values </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>Vector to integrate </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>value of integration </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>data class to store Trapzy and Trapzz value and flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9532b226f676d6567d503f4c66be2f24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPE::update_Closure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>qp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code>50</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the closure equation \( \int_\Omega \hat{\textbf{q}}^\dagger \hat{\textbf{q}}_x dy \) and output the result This is part of the solution procedure shown in the bottom half of this diagram  <style>div.image img[src="SolutionProcedure.png"]{width:8.5in;}</style>  </p>
<div class="image">
<img src="SolutionProcedure.png" alt="SolutionProcedure.png"/>
<div class="caption">
Solution Procedure</div></div>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to store values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>q at previous marching step </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">qp1</td><td>current marching step </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">alpha</td><td>\( \alpha \) value at current marching step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxiter</td><td>maximum number of iterations (not implimented) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad07d10ac9e1461899bb05d30eb41ae43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPE::update_Nonlinear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSPE_1_1SPE.html">SPE</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec &amp;&#160;</td>
          <td class="paramname"><em>qp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>alpha_old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>Ialpha_old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>Ialpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscInt &amp;&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code>50</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>advance the Nonlinear <a class="el" href="namespaceSPE.html" title="Namespace containing all functions and data classes for this solver. ">SPE</a> system one x step </p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>data class to store values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>q at previous marching step </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">qp1</td><td>current marching step </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">alpha_old</td><td>\( \alpha \) value at previous marching step (will be updated) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">alpha</td><td>\( \alpha \) value at current marching step </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Ialpha_old</td><td>\( \int_{x_0}^{x_{i+1}} \alpha dx \) value at previous marching step </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Ialpha</td><td>\( \int_{x_0}^{x_{i+1}} \alpha dx \) value at current marching step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxiter</td><td>maximum number of iterations (not implimented) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
